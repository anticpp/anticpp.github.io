<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>supergui</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="旗帜鲜明的站在C++的对立面">
<meta property="og:type" content="website">
<meta property="og:title" content="supergui">
<meta property="og:url" content="http://anticpp.github.io/index.html">
<meta property="og:site_name" content="supergui">
<meta property="og:description" content="旗帜鲜明的站在C++的对立面">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="supergui">
<meta name="twitter:description" content="旗帜鲜明的站在C++的对立面">
  
    <link rel="alternate" href="/atom.xml" title="supergui" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">supergui</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">迁于乔木，出自幽谷</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://anticpp.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-message-queue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/04/message-queue/" class="article-date">
  <time datetime="2021-03-04T02:15:47.000Z" itemprop="datePublished">2021-03-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/04/message-queue/">Message queue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>不同的消息队列的消息语义</p>
<h2 id="nsq"><a href="#nsq" class="headerlink" title="nsq"></a>nsq</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                               Consumer Group</span><br><span class="line">                                 --------</span><br><span class="line">topic --        ------------------- C0  |</span><br><span class="line">       |       \|/               |      |</span><br><span class="line">       --&gt; channel0 &lt;-------------- C1  |</span><br><span class="line">       |       /|\               |      |</span><br><span class="line">       |        ------------------- C2  |</span><br><span class="line">       --&gt; channel1              |      |</span><br><span class="line">       |                         --------</span><br><span class="line">       --&gt; channel2</span><br></pre></td></tr></table></figure>
<ul>
<li>分发</li>
</ul>
<p>每一个topic会分发到多个channel，每个channel是独立的队列。不同的Consumer Group消费不同的channel。</p>
<ul>
<li>流控</li>
</ul>
<p>每一个消费者实例，通过RDY告知nsq自己的处理窗口大小，消费者通过RDY来控制消息的处理吞吐。同一个channel的消息，只会分发给Consumer Group的一个实例。</p>
<ul>
<li>并发</li>
</ul>
<p>channel对同一个消费者实例，会并发通知多个消息，取决于消费者实例的RDY。channel对于多个消费者实例，也会并行通知。也就是如果想提高消费的吞吐，可以提高每一个消费者实例的RDY大小，也可以增加消费者实例。</p>
<ul>
<li>有序性</li>
</ul>
<p>由于channel的通知并行性，以及消息的REQUEUE语义，消息的有序性不保证</p>
<h2 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">topic --                       Consumer Group</span><br><span class="line">       |                         ---------</span><br><span class="line">       --&gt; partition0 &lt;------------- C0  |</span><br><span class="line">       |                         |       |                          </span><br><span class="line">       --&gt; partition1 &lt;------------- C1  |</span><br><span class="line">       |                         |       |</span><br><span class="line">       --&gt; partition2 &lt;------------- C2  |</span><br><span class="line">                                 |       |</span><br><span class="line">                                 |   C3  |</span><br><span class="line">                                 ---------</span><br></pre></td></tr></table></figure>
<ul>
<li>分发</li>
</ul>
<p>kafka内部会维护每一个Consumer Group对topic的消费状态(offset)，不同的Consumer Group可以单独订阅消费，互相不影响。</p>
<ul>
<li>流控</li>
</ul>
<p>消费者主动拉取消息，并且自行调整消息offset</p>
<ul>
<li>并发</li>
</ul>
<ol>
<li>同一个消费者实例可以同时拉取多个消息进行并行消费，然后一次性调整offset</li>
<li>topic可以进行多个partition，多个partition可以有多个消费者实例并行进行消费</li>
</ol>
<ul>
<li>有序性</li>
</ul>
<p>kafka保证topic的每一个partition是顺序的</p>
<p>由于channel的通知并行性，以及消息的REQUEUE语义，消息的有序性不保证</p>
<h2 id="pulsar"><a href="#pulsar" class="headerlink" title="pulsar"></a>pulsar</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2021/03/04/message-queue/" data-id="ckluhuofv00085sp3r92lva5k" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mq/">mq</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gopher-2018" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/11/gopher-2018/" class="article-date">
  <time datetime="2018-05-11T15:28:16.000Z" itemprop="datePublished">2018-05-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/11/gopher-2018/">Gopher 2018 shanghai memo</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>记录一下参加gopher 2018的东西</p>
<h2 id="Go在Grab地理服务中的实践"><a href="#Go在Grab地理服务中的实践" class="headerlink" title="Go在Grab地理服务中的实践"></a>Go在Grab地理服务中的实践</h2><ul>
<li><p>geohash<br>  基于坐标的hash，快速查找附近的司机</p>
</li>
<li><p>goreplay<br>  流量抓取</p>
</li>
<li><p>go-torch<br>  火焰图</p>
</li>
</ul>
<h2 id="Error-handling-in-Go-2"><a href="#Error-handling-in-Go-2" class="headerlink" title="Error handling in Go 2"></a>Error handling in Go 2</h2><ul>
<li>github.com/mpvl/errc</li>
<li>github.com/mpvl/errd</li>
<li>try &amp; handle</li>
<li>refer: Go: the Good, the Bad and the Ugly</li>
</ul>
<h2 id="Why-we-design-a-fast-key-value-database"><a href="#Why-we-design-a-fast-key-value-database" class="headerlink" title="Why we design a fast key-value database"></a>Why we design a fast key-value database</h2><ul>
<li>motivation</li>
<li>levelDB, RocksDB</li>
<li>LSM Trees/B+ Trees</li>
<li>Separate keys from values.</li>
<li>Key stored in <code>LSM</code> Tree</li>
<li>Value stored in value log.</li>
<li>CGO evil</li>
</ul>
<h2 id="IPFS"><a href="#IPFS" class="headerlink" title="IPFS"></a>IPFS</h2><ul>
<li>DHT</li>
</ul>
<h2 id="Composition-in-Go"><a href="#Composition-in-Go" class="headerlink" title="Composition in Go"></a>Composition in Go</h2><ul>
<li>Interface decouple: What you do makes who you are.</li>
<li><a href="https://gogoing" target="_blank" rel="external">https://gogoing</a>.</li>
</ul>
<h2 id="Bazel-build-go"><a href="#Bazel-build-go" class="headerlink" title="Bazel build //:go"></a>Bazel build //:go</h2><ul>
<li>Bazel</li>
<li>vgo</li>
</ul>
<h2 id="CGO"><a href="#CGO" class="headerlink" title="CGO"></a>CGO</h2><ul>
<li>Soooooooooooo complex</li>
</ul>
<h2 id="arm64的go工具链"><a href="#arm64的go工具链" class="headerlink" title="arm64的go工具链"></a>arm64的go工具链</h2><ul>
<li><code>go tool</code></li>
<li>go assembler,/………………</li>
<li><code>go build -x test.go</code></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2018/05/11/gopher-2018/" data-id="ckluhuofy000g5sp3x3i5h61x" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/meeting/">meeting</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-cpp-virtual-vs-go-interface" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/05/cpp-virtual-vs-go-interface/" class="article-date">
  <time datetime="2018-05-04T19:01:17.000Z" itemprop="datePublished">2018-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/05/cpp-virtual-vs-go-interface/">Go interface internal</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>运行期的多态，是很多高级语言的很重要的特性。我们可以在运行期根据实际创建的对象，决定实际所要运行的函数。<br>C++可以通过virtual member function实现运行期的多态，同样，在Go我们可以通过interface实现类似的机制。虽然C++的virtual和Go的interface本质上还是有很多区别，但是不妨碍我们深入探讨一下关于如何实现运行期多态。</p>
<blockquote>
<p>Note: </p>
<ol>
<li>不去理解实现机制，并不影响我们使用C++或者Go（只要遵循语言的标准并不会有什么麻烦）。当然，如果能更深入的理解实现，本身有利于加深我们对代码的理解。</li>
<li>我们讨论的的实现很可能只代表主流编译器的实现，并不一定代表语言的标准。编译器需要遵循语言规范去实现，但是如何实现往往是编译器自己的决定。</li>
</ol>
</blockquote>
<h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><p>我们都知道C++的多态，通过基类里面把成员函数定义为virtual，继承类可以重新实现这个函数。使用一个基类的指针指向对象，并且通过该指针执行那个函数，具体执行的是基类还是继承类的函数，取决于运行期该对象的类型。C++的多态/继承当然没有那么简单，还有非常多的细节特性，想要完全说明白几乎不可能（建议去翻C++标准或者经典类的书）。我们这里只需要用最简单的例子，去说明实现的原理。</p>
<p>例如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func() &#123; std::cout &lt;&lt; &quot;Hello Base&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class D : public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void func() &#123; std::cout &lt;&lt; &quot;Hello D&quot; &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// main.cpp</span><br><span class="line">Base *p = new D();</span><br><span class="line">p-&gt;func();</span><br></pre></td></tr></table></figure>
<p>由于指针p指向的对象，实际上是类型D。而且<code>func()</code>定义为<code>virtual</code>，所以实际执行的是D的<code>func()</code>，程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello D</span><br></pre></td></tr></table></figure>
<h2 id="C-vtable"><a href="#C-vtable" class="headerlink" title="C++ vtable"></a>C++ vtable</h2><p>C++通过vtable实现多态，C++在<strong><em>编译期</em></strong>给每个类生成一个vtable。vtable就是一个函数地址数组，记录了这个类所有的virtual function指向的函数地址。只要该类声明了function为virtual，或者它的父类/祖先类声明了virtual，则该function就是virtual。</p>
<p>例如，<code>class D</code>的vtable只包涵一个元素，就是<code>func</code>的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class D : vtable --&gt; -----------</span><br><span class="line">                     | D::func |</span><br><span class="line">                     -----------</span><br><span class="line">                     |  null   |(null for array end)</span><br><span class="line">                     -----------</span><br></pre></td></tr></table></figure>
<p>这里需要注意，<code>class D</code>的<code>func</code>没有指向<code>Base::func</code>，而是指向了<code>D::func</code>，是由于<code>class D</code>重新实现了<code>virtual func</code>。如果<code>class D</code>没有实现<code>virtual func</code>，那么<code>class D</code>的<code>func</code>会指向<code>Base::func</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class D : vtable --&gt; --------------</span><br><span class="line">                     | Base::func |</span><br><span class="line">                     --------------</span><br><span class="line">                     |  null      |(null for array end)</span><br><span class="line">                     --------------</span><br></pre></td></tr></table></figure>
<p>那么，vtable是怎么使用的呢。在我们创建对象的时候，编译器会在创建对象的内存的开始插入vtable的地址指针vptr(很tricky)。例如，我们<code>new D()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                                           vtable</span><br><span class="line">p = new D() -----&gt; ------------          -----------</span><br><span class="line">                   |  vptr    | --------&gt;| D::func |</span><br><span class="line">                   ------------          -----------</span><br><span class="line">                   |          |          |  null   |</span><br><span class="line">                   | D object |          -----------</span><br><span class="line">                   |          |</span><br><span class="line">                   ------------</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以即使是一个空的class，如果有virtual function，那么该class的sizeof也不会是0，而是一个指针的大小(sizeof(void *))。</p>
</blockquote>
<p>当我们通过该对象调用<code>func</code>的时候，因为该function为virtual，会通过<code>vptr</code>找到<code>vtable</code>，并且在<code>vtable</code>里面找到<code>func</code>的地址，并且执行。</p>
<p>C++通过vtable实现了运行期的多态，但是vtable是在编译器静态绑定，运行期需要进行vtable的查找。</p>
<h2 id="Go-interface"><a href="#Go-interface" class="headerlink" title="Go interface"></a>Go interface</h2><p>Go的interface是Go语言一个很重要的设计，借鉴了Java和C++的部分语言特性，最大的改变是去掉了C++和Java里面的显示继承。interface只是单纯的定义分行为（方法），如果我们要定义一种类型属于该interface，并不需要显示的继承该interface，只需要对该类型实现所有interface所声明的方法，那么这个类型就是属于该interface。</p>
<p>这里涉及的设计哲学是<code>What I do makes who I am</code>，不同于C++/Java的<code>I declare who I am</code>。这是一种充分<code>解耦</code>的设计哲学，打破 了类型之间的强耦合。其实跟现实世界很像，你是什么样的人，不取决于你自己怎么说或者你身上的既定的标签，而取决于你自己的行为。例如，你成天跟大家说你是君子不代表你就是一个君子，你的君子行径才能决定。嗯，有点跑题了，我们还是回到正轨。</p>
<p>例如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Base interface &#123;</span><br><span class="line">    func()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type D struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (d *D) func() &#123;</span><br><span class="line">    fmt.Println(&quot;Hello D&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// main.go</span><br><span class="line">var p Base = new(D)</span><br><span class="line">p.func()</span><br></pre></td></tr></table></figure>
<p>由于p指向的对象，实际上是类型D，所以最后执行的是D的<code>func()</code>，程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello D</span><br></pre></td></tr></table></figure>
<h2 id="Go-itable"><a href="#Go-itable" class="headerlink" title="Go itable"></a>Go itable</h2><p>Go的interface结构包含2部分，第一部分是指向实际对象的value，第二部分是一个地址数组<code>itable</code>（有点像C++的vtable）。例如<code>interface Base</code>的结构如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Base --&gt;  -------------</span><br><span class="line">          |   value   |</span><br><span class="line">          -------------         ---------</span><br><span class="line">          |  itable   | -----&gt;  |  func |</span><br><span class="line">          -------------         ---------</span><br><span class="line">                                |  null |</span><br><span class="line">                                ---------</span><br></pre></td></tr></table></figure>
<p>当我们执行<code>var p Base = new(D)</code>时，会把左值拷贝给value，并且通过查找<code>D</code>的函数列表组装<code>itable</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Base --&gt;  -------------                                        -------------------</span><br><span class="line">          |   value   |-------------------------------------&gt;  | address of D()  |</span><br><span class="line">          -------------         ---------                      -------------------</span><br><span class="line">          |  itable   | -----&gt;  |  func |---------------</span><br><span class="line">          -------------         ---------              |            -------------</span><br><span class="line">                                |  null |              |----------&gt; | D::func() |</span><br><span class="line">                                ---------                           -------------</span><br></pre></td></tr></table></figure>
<p>所以，当我们执行<code>p-&gt;func()</code>时，编译器已经知道具体执行的是<code>D::func()</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++和Go interface内部实现机制并不一样，但是都可以实现运行期的多态绑定。就是说，我们可以根据运行期实际创建的对象是什么，来决定运行的函数。</p>
<p>C++通过编译器静态产生vtable的方式实现，但是需要在运行期进行vtable查找，会带来运行期开销。</p>
<p>Go interface在运行期计算itable，好处是在执行的时候基本上是O(1)开销。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2018/05/05/cpp-virtual-vs-go-interface/" data-id="ckluhuofr00035sp333mh6kkk" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/programing-lanuage/">programing lanuage</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-private-addr" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/03/private-addr/" class="article-date">
  <time datetime="2018-05-03T06:22:20.000Z" itemprop="datePublished">2018-05-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/03/private-addr/">IPv4 private address</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h2><p><a href="https://www.iana.org" target="_blank" rel="external">Internet Assigned Number Authority(IANA)</a>定义了一系列保留的私有地址，用来在路由器内部或者NAT内部进行组网。私有地址指允许在内网进行路由，如果这些地址跑到公网，所有的公网路由不会对这些地址进行路由。</p>
<h2 id="地址段"><a href="#地址段" class="headerlink" title="地址段"></a>地址段</h2><ul>
<li>A类地址</li>
</ul>
<p>10.0.0.0/8: 10.0.0.0 - 10.255.255.255</p>
<ul>
<li>B类地址</li>
</ul>
<p>172.16.0.0/12: 172.16.0.0 - 172.31.255.255</p>
<ul>
<li>C类</li>
</ul>
<p>192.168.0.0/16: 192.168.0.0- 192.168.255.255</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2018/05/03/private-addr/" data-id="ckluhuofy000d5sp3z5op5icd" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IP/">IP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-dht" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/17/dht/" class="article-date">
  <time datetime="2018-04-17T13:03:24.000Z" itemprop="datePublished">2018-04-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/17/dht/">DHT</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>BT作为历史上最成功的P2P文件系统，已经在全球实现了彻底的去中心化。BT的P2P网络，不依赖任何机构或者中心依然能够很好的运行。<br>这里面，最关键的设计是引入了DHT。这里我们主要介绍一下为什么要引入DHT，以及DHT的基本原理。</p>
<p>BT作为一种P2P系统，面临<strong><em>资源索引</em></strong>问题，简单来说<strong><em>资源索引</em></strong>维护资源(resource)当前有哪些节点(peer)也在同时下载的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">res0 -&gt; peerA,peerB,...</span><br><span class="line">res1 -&gt; peerC,peerD,...</span><br><span class="line"></span><br><span class="line">                         ------------------------------</span><br><span class="line">              Index ---&gt; | res0 | res1 | ...          |</span><br><span class="line">                         ------------------------------</span><br><span class="line">                            |      |</span><br><span class="line">                           \|/    \|/</span><br><span class="line">                         ------- -------</span><br><span class="line">                         |peerA| |peerC|</span><br><span class="line">                         ------- -------</span><br><span class="line">                         |peerB| |peerD|</span><br><span class="line">                         ------- -------</span><br></pre></td></tr></table></figure>
<h2 id="2-中心化"><a href="#2-中心化" class="headerlink" title="2. 中心化"></a>2. 中心化</h2><p>BT的数据传输本身是去中心化的，每一个peer会同时从网络上搜索到的其它peer进行数据传输。<br>但是<strong><em>资源索引</em></strong>一开始还是中心化的解决方案，就是Tracker。虽然网络上有很多提供Tracker的服务，每一个客户端也可以设置若干个Tracker，但是Tracker依然是一个中心化的服务。</p>
<p>Tracker原理很简单，提供了上报和查询服务。如下图：正在下载某一个资源(res)的BT客户端peer2把资源上报给Tracker。下载资源的BT客户端(peer1)可以到Tracker查询时下载这个资源的peer2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">           --------------    -----------------------------------</span><br><span class="line">      |---&gt;| Tracker    | -- |           Index                 |</span><br><span class="line">      |    --------------    -----------------------------------</span><br><span class="line">      |     |         /|\   </span><br><span class="line">      |     |          |</span><br><span class="line">      |     |          |</span><br><span class="line">query |     |resp      |</span><br><span class="line">      |     |(peer2)   |</span><br><span class="line">      |     |          |    report res</span><br><span class="line">      |     |          |----------------</span><br><span class="line">      |    \|/                         |</span><br><span class="line">   -----------                     ---------</span><br><span class="line">   |  peer1  |                     | peer2 |</span><br><span class="line">   -----------                     ---------</span><br></pre></td></tr></table></figure>
<p>Tracker提供了一种简单高效的方案，解决了资源索引的问题。缺点是一旦Tracker不可用，BT的P2P网络也就随之瘫痪(可以参考海盗湾事件)。这是所有中心化服务必将面临的问题，为了让整个P2P网络更加健壮，需要探索一个去中心化的实现。</p>
<h2 id="3-去中心化"><a href="#3-去中心化" class="headerlink" title="3. 去中心化"></a>3. 去中心化</h2><p>考虑没有中心化的Tracker，我们需要一个去中心化的方式，把资源的索引存储(sharding)到全网的节点，并且能高效的查询。</p>
<h3 id="3-1-全量"><a href="#3-1-全量" class="headerlink" title="3.1 全量"></a>3.1 全量</h3><p>最简单的办法，就是让每一个Node(节点)都维护一个全量的索引，相当于每个Node都是一个Tracker节点。</p>
<blockquote>
<p>注意：我们需要区分一下Node和Peer的概念，以下是DHT的papper的描述<br>A “peer” is a client/server listening on a TCP port that implements the BitTorrent protocol. A “node” is a client/server listening on a UDP port implementing the distributed hash table protocol. </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--------------    -----------------------------------</span><br><span class="line">| Node0      | -- |           Index                 |</span><br><span class="line">--------------    -----------------------------------</span><br><span class="line"></span><br><span class="line">--------------    -----------------------------------</span><br><span class="line">| Node1      | -- |           Index                 |</span><br><span class="line">--------------    -----------------------------------</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">--------------    -----------------------------------</span><br><span class="line">| NodeN      | -- |           Index                 |</span><br><span class="line">--------------    -----------------------------------</span><br></pre></td></tr></table></figure>
<p>这种方案有几个明显的问题</p>
<ol>
<li>每个索引的变更需要扩散到全网，效率太差</li>
<li>海量的索引，每个单点都需要全量存储，代价太大</li>
</ol>
<h3 id="3-2-Sharding"><a href="#3-2-Sharding" class="headerlink" title="3.2 Sharding"></a>3.2 Sharding</h3><p>基本的思路是，我们需要把索引数据按照<strong><em>一定规则</em></strong>分布(sharding)到全网的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    -----------       -----------     -----------                   -----------</span><br><span class="line">    |  Node0  |       |  Node1  |     |  Node2  |       ...         |  NodeN  |</span><br><span class="line">    -----------       -----------     -----------                   -----------</span><br><span class="line">       /|\                 /|\            /|\                            /|\</span><br><span class="line">        |--------           |              |                              |</span><br><span class="line">                 |          |              |                              |</span><br><span class="line">            -----------------------------------------------------------------------</span><br><span class="line">Index ----&gt; |  shard0    |  shard1    |   shard2     |  ...      |    shardN      |</span><br><span class="line">            -----------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>一致性Hash是一种常用的办法，首先把Node散列(hash<nodeid>)到一个整数的空间，这样每一个Node负责一个范围段的索引。<br>同样，我们可以把资源也计算一个整数的hash。<br>例如，NodeA负责范围<code>[i, j)</code>的范围，那么如果索引按照分布规则在范围内，那么该索引就由NodeA负责存储。</nodeid></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// NodeA covers [i, j).</span><br><span class="line">// Use hash(resource) to caculate resource.</span><br><span class="line">if i &lt; hash(resource) &lt; j &#123;</span><br><span class="line">    store(resource, NodeA) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里盗用一个网上的一致性Hash图片，具体的算法这里就不重复介绍了。</p>
<p><img src="/images/dht-constant-hash.jpg" alt=""></p>
<p>一致性Hash解决了sharding的问题，但是一致性Hash引入了Hash环状态。在系统中如何维护Hash状态数据，跟如何维护资源索引面临一样的问题。</p>
<p>我们需要彻底解决状态数据的问题，才能真正实现去中心化。</p>
<h2 id="4-DHT"><a href="#4-DHT" class="headerlink" title="4. DHT"></a>4. DHT</h2><p>DHT(Distributed Hash Table)，就是分布式Hash table。实际上也是Sharding的一种实现方法，DHT可以看作是一致性Hash的基础上的改进。一致性Hash算法的问题是Hash环的状态数据，只要我们能设计出一种关于索引分布规则的去中心化的<strong><em>共识机制</em></strong>，我们并不需要去维护一个Hash环。关于DHT的比较完整的介绍，可以参考<a href="http://www.bittorrent.org/beps/bep_0005.html" target="_blank" rel="external">DHT Protocol</a>。</p>
<p>DHT设计了这样一种去中心化的<strong><em>共识机制</em></strong>：索引信息应该存储到到距离目标<strong><em>更近</em></strong>的节点。</p>
<h3 id="4-1-Hash"><a href="#4-1-Hash" class="headerlink" title="4.1 Hash"></a>4.1 Hash</h3><p>DHT网络中每个节点的NodeID就是一个hash值，每个资源也有一个hash。</p>
<h3 id="4-2-距离"><a href="#4-2-距离" class="headerlink" title="4.2 距离"></a>4.2 距离</h3><p>用来计算2个hash的距离，Node和Node之间可以有距离，Node和资源之间也可以有距离。要注意的是，这个距离并不是实际意义上的距离，只是一个算法上的需要。</p>
<h3 id="4-3-Routing-table"><a href="#4-3-Routing-table" class="headerlink" title="4.3 Routing table"></a>4.3 Routing table</h3><p>DHT网络中每个Node都维护一个Routing table（路由表），这是DHT的核心部分，它保存本节点和网络中一小部分节点信息。每一个节点，都能够提供查询接口，并且能够返回距离目标hash<strong><em>更近</em></strong>的节点。这样通过网络中递归查询Routihng table，可以不断的趋向<strong><em>更近</em></strong>。IPFS把这个过程总结为<a href="https://github.com/libp2p/specs/blob/master/4-architecture.md#41-peer-routing" target="_blank" rel="external">Peer Routing</a>的过程。我们可以用Peer routing解决DHT的<strong><em>共识机制</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                   ---------------------------------------------</span><br><span class="line">Routing table --&gt;  | NodeInfo0 | NodeInfo1 | ...   | NodeInfoN |</span><br><span class="line">                   ---------------------------------------------</span><br></pre></td></tr></table></figure>
<p>我们以查询资源为例，一个典型的Query Resource过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 ) client需要查找目标资源hash，先到Node0进行查询。</span><br><span class="line">2 ) 如果Node0本地有这个hash的索引，则返回结果</span><br><span class="line">3 ) 如果Node0本地没有这个hash的索引，Node0从自己的Routing table查找离目标hash更近的节点，例如Node1和Node2</span><br><span class="line">4 ) client对Node1和Node2重复过程1的查询，直到有查询到有结果</span><br><span class="line"></span><br><span class="line">           1) query hash       -----------</span><br><span class="line">client  --------------------&gt;  |         |</span><br><span class="line">        &lt;-------------------   |  Node0  |</span><br><span class="line">           2 ) Resource        |         |</span><br><span class="line">           3 ) Node1,Node2     -----------</span><br><span class="line"></span><br><span class="line">           4 ) query hash      -----------</span><br><span class="line">        --------------------&gt;  |  Node1  |</span><br><span class="line">                               -----------</span><br><span class="line"></span><br><span class="line">           4 ) query hash      -----------</span><br><span class="line">        --------------------&gt;  |  Node2  |</span><br><span class="line">                               -----------</span><br></pre></td></tr></table></figure></p>
<h2 id="5-Kademlia"><a href="#5-Kademlia" class="headerlink" title="5. Kademlia"></a>5. Kademlia</h2><p>DHT有很多不同的实现，这里主要介绍Kademlia，一般我们叫KAD。现在大部分的DHT都是基于KAD实现，或者KAD的一些改进。<br>KAD使用k-bucket(k桶)实现Routing table，能实现log2(N)的查找效率。假设1000000节点的规模的网络，可以最多20次查询能够完成全网节点的查询。</p>
<p>关于KAD的实现有很多细节，我们这里着重介绍为什么k-bucket能实现log2(N)的查找效率。</p>
<h3 id="5-1-距离"><a href="#5-1-距离" class="headerlink" title="5.1 距离"></a>5.1 距离</h3><p>KAD使用XOR(按位异或)对两个hash进行距离计算，为什么要使用异或？我们后面结合k桶可以看到，这是经过精心设计的算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distance(A, B) = A xor B</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Routing-table"><a href="#5-2-Routing-table" class="headerlink" title="5.2 Routing table"></a>5.2 Routing table</h3><p>KAD使用K桶(K-bucket)实现Routing table，K桶实际上是一个hash table。Hash table的大小取决于我们使用hash的位数，因为KAD使用sha1做hash算法，sha1的hash结果为160位，所以KAD的K桶大小为160。</p>
<p>那么K是什么意思呢，KAD限制了每个桶最多能存储K个节点信息，所以叫K桶。默认的KAD实现K一般为8。</p>
<blockquote>
<p>实际的实现是K桶大小初始化为1，随着每个桶的节点数量超过K，K桶会进行对半分裂。由于不是关键点，我们这里就不详细介绍。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">               -----------------------------------------------------------------------</span><br><span class="line">K-bucket ---&gt;  |  0  |  1  |  2  |                  ...                 | 158  | 159 |</span><br><span class="line">               -----------------------------------------------------------------------</span><br><span class="line">                  |</span><br><span class="line">                 \|/</span><br><span class="line">               ------------</span><br><span class="line">            -- | NodeInfo |</span><br><span class="line">            |  ------------</span><br><span class="line">            |  | NodeInfo |</span><br><span class="line">         K &lt;   ------------</span><br><span class="line">            |  |   ...    |</span><br><span class="line">            |  ------------</span><br><span class="line">            -- | NodeInfo |</span><br><span class="line">               ------------</span><br></pre></td></tr></table></figure>
<h3 id="5-3-K桶算法"><a href="#5-3-K桶算法" class="headerlink" title="5.3 K桶算法"></a>5.3 K桶算法</h3><p>那么，一个NodeInfo应该放到哪个桶呢。KAD的算法是，越小(具体实现也可能是越大，算法本质都一样)的桶存储的NodeInfo距离本节点的ID越远，并且每递增一个桶，距离折半。可以用按bit前缀匹配来实现，简单来说，第N个桶存储的节点NodeID与当前节点的NodeID前N-1位相同，第N位不同。</p>
<p>上面的描述还是有点晦涩，大家可以简单推算一下(XOR计算距离)，第0个桶上面的NodeInfo的ID所有的bit跟本节点ID都不一样（距离2^N，最远），最后一个桶的NodeInfo的ID只有最后一个bit跟本节点ID不一样（距离2^0=1）。</p>
<p>按照这个算法，有几个比较明显的结论是：</p>
<ol>
<li>越大的桶存储的是离本节点越<strong><em>近</em></strong>的节点信息(XOR计算距离)</li>
<li>第N+1个桶存储的节点，比第N个桶存储的节点，距离本节点近了<strong><em>一半</em></strong>。也就是每递增一个桶，节点数量<strong><em>折半</em></strong>。</li>
<li>桶内所有的节点之间的距离，都一定比桶内节点跟本节点的距离，至少更近<strong><em>一半</em></strong>。(桶内节点跟本节点第N位不同，那么这些节点之间的第N位一定相同，也就是这些节点之间的前N位都相同)</li>
</ol>
<p>我门用一个K桶大小为4的例子说明:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 假如节点0000保存了全部节点信息，实际上网络很大的时候一个节点的K桶只会保存一部分节点信息</span><br><span class="line">// 下面为节点0000上的K桶</span><br><span class="line"></span><br><span class="line">          -------------------------</span><br><span class="line">          |  0  |  1  |  2  |  3  |</span><br><span class="line">          -------------------------</span><br><span class="line">           1000  0100  0010  0001</span><br><span class="line">           1001  0101  0011</span><br><span class="line">           1010  0110  </span><br><span class="line">           1011  0111</span><br><span class="line">           1100</span><br><span class="line">           1101</span><br><span class="line">           1110</span><br><span class="line">           1111</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ol>
<li>第1个桶节点和本节点距离，比第0个桶节点和本节点的距离，更近。(例如 (0100 xor 0000 = 0100) &lt; (1000 xor 0000 = 1000) )</li>
<li>第1个桶的节点数量，是第0个桶节点数量的一半。也就是越大的桶，节点数量是折半。</li>
<li>第0个桶，内部的节点距离，会比本节点距离至少更近<strong><em>一半</em></strong>。(例如 1000 xor 1001 = 0001, 1000 xor 0000 = 1000)</li>
</ol>
<h3 id="5-4-折半效率"><a href="#5-4-折半效率" class="headerlink" title="5.4 折半效率"></a>5.4 折半效率</h3><p>所以，为什么KAD能够实现log2(N)的折半查找效率呢。</p>
<p>假如我们要查找/存储的目标为资源target，第一轮查询我们到节点Node0进行查询，Node0进行的操作为：</p>
<ol>
<li>如果Node0拥有target资源，则返回</li>
<li>否则，计算target和Node0的距离所对应的K桶，例如为N</li>
<li>返回第N个桶的K个新节点信息</li>
</ol>
<p>考虑第3)步，返回给客户端的这K个新节点，我们很容易得出一个结论：target和新节点的距离，至少比和Node0的距离<strong><em>近一半</em></strong>。</p>
<blockquote>
<p>由于target和Node0计算距离定位到第N个桶，也就是target和Node0也是前缀关系，前N-1位相同，第N位不同。<br>再由于，”桶内所有的节点之间的距离，都一定比桶内节点跟本节点的距离，至少更近<strong><em>一半</em></strong>“。</p>
</blockquote>
<p>客户端拿到离目标更近一半的新节点，继续进行下一轮查询，每递归一轮查找都能<strong><em>折半</em></strong>趋近。</p>
<h2 id="6-结论"><a href="#6-结论" class="headerlink" title="6 结论"></a>6 结论</h2><p>虽然我们这里忽略了很多DHT和KAD的实现细节，但是可以看到KAD通过K桶的Peer routing，能够实现折半效率的Peer routing。从而，我们可以通过Peer routing查找/存储到距离目标<strong><em>最近</em></strong>的节点，实现一个<strong><em>共识机制</em></strong>。</p>
<p>DHT作为去中心化的实现，相对中心化的Tracker，牺牲的是效率(慢扩散查找)和一致性(最终一致)，换来的是网络的健壮性。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2018/04/17/dht/" data-id="ckluhuofd00005sp3uwkvqomu" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dht/">dht</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/p2p/">p2p</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-openssl-tools" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/24/openssl-tools/" class="article-date">
  <time datetime="2016-11-24T09:34:05.000Z" itemprop="datePublished">2016-11-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/24/openssl-tools/">Openssl tools</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-生成rsa密钥文件"><a href="#1-生成rsa密钥文件" class="headerlink" title="1. 生成rsa密钥文件"></a>1. 生成rsa密钥文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/cakey.pem</span><br></pre></td></tr></table></figure>
<h1 id="2-查看密钥文件"><a href="#2-查看密钥文件" class="headerlink" title="2. 查看密钥文件"></a>2. 查看密钥文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -noout -text -in private/cakey.pem</span><br></pre></td></tr></table></figure>
<h1 id="3-生成CSR"><a href="#3-生成CSR" class="headerlink" title="3. 生成CSR"></a>3. 生成CSR</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server_key.pem -out server_csr.pem</span><br></pre></td></tr></table></figure>
<pre><code>依赖：密钥文件server_key.pem
</code></pre><h1 id="4-查看CSR信息"><a href="#4-查看CSR信息" class="headerlink" title="4. 查看CSR信息"></a>4. 查看CSR信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -noout -text -in server_csr.pem</span><br></pre></td></tr></table></figure>
<h1 id="5-生成证书"><a href="#5-生成证书" class="headerlink" title="5. 生成证书"></a>5. 生成证书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key private/cakey.pem -out cacert.pem</span><br></pre></td></tr></table></figure>
<p>依赖：密钥文件cakey.pem</p>
<h1 id="6-对CSR签名，生成证书"><a href="#6-对CSR签名，生成证书" class="headerlink" title="6. 对CSR签名，生成证书"></a>6. 对CSR签名，生成证书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -in server_csr.pem -out server_crt.pem</span><br></pre></td></tr></table></figure>
<h1 id="6-查看证书"><a href="#6-查看证书" class="headerlink" title="6. 查看证书"></a>6. 查看证书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -noout -text -in server_crt.pem</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/11/24/openssl-tools/" data-id="ckluhuoft00075sp30ywymx47" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/openssl/">openssl</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/tools/">tools</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ssl-tls" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/23/ssl-tls/" class="article-date">
  <time datetime="2016-11-23T06:12:57.000Z" itemprop="datePublished">2016-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/23/ssl-tls/">ssl/tls</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在折腾Microservice的gRPC鉴权问题，顺带梳理了下ssl/tls的原理。<br>以前没有特别深究过里面的问题，最近大概都算理清楚了，这里Mark也下。</p>
<h1 id="1-ssl-tls"><a href="#1-ssl-tls" class="headerlink" title="1. ssl/tls"></a>1. ssl/tls</h1><p>ssl/tls是一套基于非对称加密的安全协议，实际上ssl和tls是两个版本，大多数情况下这两个名词一起被提到，可以理解为tls是ssl的升级版本。</p>
<h1 id="2-https"><a href="#2-https" class="headerlink" title="2. https"></a>2. https</h1><p>其实https是泛指http over secure，是在http协议之上增加的安全协议。当然，也有人会把它理解为http over ssl或者http over tls。<br>一般我们提到https都会默认提到ssl/tls，是因为ssl/tls在当前是最成熟的应用到https上。</p>
<h1 id="3-ssl-tls握手"><a href="#3-ssl-tls握手" class="headerlink" title="3. ssl/tls握手"></a>3. ssl/tls握手</h1><p>实际上https在安全机制上是做了两个事情，我们常常也会忽略。</p>
<ul>
<li>加密传输</li>
<li>证书校验</li>
</ul>
<p>握手的过程大概如下</p>
<ul>
<li>Client端发送ClientHello给Server端。包含协议版本、一个随机数(Random1)、支持的加密算法、压缩算法等。</li>
<li>Server端发送ServerHello给Client端。包含协议版本的确认、一个随机数(Random2)、确认的加密算法、压缩算法等。</li>
<li>Server端发送Certificate(证书)给Client端。</li>
<li>Server端发送ServerHelloDone给Client端。</li>
<li>Client端发送ClientKeyExchange给Server端。包含一个随机数PreMasterSecret，并且PreMasterSecret要用证书里面的公钥进行加密。</li>
<li><p>Server端用自己的私钥把PreMasterSecret解开。Client和Server都用Random1、Random2、PreMasterSecret算出来MasterSecret，这个MasterSecret就是双方约定的加密传输的对称秘钥，并且使用之前协商的加密算法，进行后续的数据交互。</p>
<p>  注意：</p>
<ol>
<li>Server端所持有的私钥和公钥（在Certificate里面），并没有参与Certificate校验的过程，只是用来做最后一个随机数PreMasterSecret的加密保障。</li>
<li>这个过程并没有描述Certificate在Client端是怎么验证的，也就是Client根据什么确认Server的签名信息。</li>
</ol>
</li>
</ul>
<h1 id="4-ssl-tls加密传输"><a href="#4-ssl-tls加密传输" class="headerlink" title="4. ssl/tls加密传输"></a>4. ssl/tls加密传输</h1><p>加密传输是https的最重要特性，保证了所有网络上的数据不会被明文探测。整个握手过程实际上是明文的，生成MasterSecret的前面两个随机数也是明文。实际最终保证安全性的关键在于，PreMasterSecret这个随机数的安全性。而这个随机数的安全性是建立在非对称加密的安全性上面。</p>
<h1 id="5-ssl-tls证书校验"><a href="#5-ssl-tls证书校验" class="headerlink" title="5. ssl/tls证书校验"></a>5. ssl/tls证书校验</h1><h2 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h2><p>证书签名的基本原理很简单，一般是利用非对称加密算法。非对秘钥一般成对出现（最常用的RSA），一个公钥，一个私钥。<br>公钥加密的信息，只有私钥能解开。同理，私钥加密的信息，只有公钥能解开。<br>例如：我用私钥加密一段内容，同时告诉对方我的公钥，对方如果可以用我的公钥解开我的内容，就可以证明这段信息是我的。这里面，被加密的内容就可以作为签名信息。</p>
<h2 id="5-2-关于CA-证书校验"><a href="#5-2-关于CA-证书校验" class="headerlink" title="5.2 关于CA/证书校验"></a>5.2 关于CA/证书校验</h2><p>ssl/tls的握手过程，往往容易忽略证书校验的过程，这个发生在握手的第3步，Server端发送证书给客户单之后，客户端是怎么验证证书的合法性呢？<br>握手的过程很简单，Server端的一组非对称秘钥，并没有参与到任何证书校验的环节，只是用来做了最后一个随机数PreMasterSecret的安全保障。</p>
<p>实际上我们Server的一对秘钥，并不是用来做证书校验，证书校验是通过另外一组非对称秘钥来保证。<br>这里就要提到<strong><em><a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="external">CA(Certificate Authority)</a></em></strong>，CA是一个权威机构，主要负责证书的签名、发放、校验等职责。<br>主要逻辑参考这个图</p>
<p><img src="/images/tls_certification.png" alt="certification_flow"></p>
<ol>
<li>CA本身有自己的一套根密钥(cakey.pem)、根证书(cacert.pem一般包含了证书信息、对应的公钥信息等)</li>
<li>Server生成自己的密钥(server_key.pem)和证书签名请求CSR(server_csr.pem)</li>
<li><p>Server拿server_csr.pem到CA进行签名，得到server_crt.pem，即最终的证书。CA签名的过程，可以简单理解为用cakey.pem对server_csr.pem增加一段加密的签名信息。这段签名信息，只有CA的公钥（公钥信息在cacert.pem可以得到）可以解开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(cakey.pem, server_csr.pem) = server_crt.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>Client端（一般是浏览器）会内置了CA的根证书(cacert.pem)。在ssl/tls握手的第3步，Client拿到Server的Certificate（这个其实就是server_crt.pem），就可以根据CA的根证书对Certificate进行验证。</p>
</li>
</ol>
<p>所以，最终证书的安全性建立在Client端的CA根证书的安全性。</p>
<pre><code>Note: 怎么保证Client端CA证书的安全性？
</code></pre><h2 id="5-3-为什么要给钱"><a href="#5-3-为什么要给钱" class="headerlink" title="5.3 为什么要给钱"></a>5.3 为什么要给钱</h2><p>正常的网站，为了做网站的证书签名，都需要找到权威的CA机构进行证书签名，而CA对这块都是要付费的。<br>那问题是，我们为什么非得找这些CA付费，自己随便搞一个假的CA进行对自己的证书进行签名不就行了吗。<br>其实也有人这样干，大家可以参考万恶的<a href="http://www.12306.cn" target="_blank" rel="external">http://12306.cn</a>。对，就是那个全世界最大的电商网站。<br>例如用Chrome访问都会提示证书不安全，因为他们并没有找权威CA进行证书签名。<br><img src="/images/https_error.png" alt="https_error"><br>CA的权威性，是建立在行业标准之上的存在，所以对浏览器厂商也会遵循这些行业标准。也就是，这些浏览器都会内置权威的CA的根证书。为了让浏览器能显示你是认证的网站 ，必须找权威的CA机构，给钱、签名。</p>
<h1 id="6-Openssl自建CA、Server数字证书"><a href="#6-Openssl自建CA、Server数字证书" class="headerlink" title="6. Openssl自建CA、Server数字证书"></a>6. Openssl自建CA、Server数字证书</h1><p>恩，为什么要自建CA呢。<br>上面说了，ssl/tls实际上是做了两个事情，加密传输和证书验证。<br>这两个事情，其实不太相关。<br>证书验证，大部分场景是在网站浏览器端，所以网站必须给权威的CA机构付费。<br>但是，如非浏览器应用，我们只是想利用xls/tls加密传输。<br>我们就完全有理由自己搞私有的CA，自己给自己发证书了。</p>
<p>Openssl工具提供了一整套完整的命令行工具，大概流程如下<br>主要做几件事情</p>
<ol>
<li>配置自己的CA</li>
<li>生成Server的密钥，CSR</li>
<li>用CSR到CA签名，生成CRT，也就是证书</li>
</ol>
<pre><code>CSR: Certificate Signing Request，证书签名请求
CRT: Certificate，证书
</code></pre><h2 id="6-1-配置CA"><a href="#6-1-配置CA" class="headerlink" title="6.1 配置CA"></a>6.1 配置CA</h2><p>如果安装了Openssl，默认的路径在/etc/pki/。<br>配置文件路径在tls/openssl.cnf，基本的配置可以不用改。<br>可以简单关注一下policy_match相关的配置，这里配置了对不同证书信息是否进行校验。</p>
<ul>
<li><p>进入CA目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd CA/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建两个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch index.txt serial</span><br><span class="line">echo 01 &gt; serial</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建根密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/cakey.pem 2048</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建根证书<br>需要用到密钥 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key private/cakey.pem -out cacert.pem</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-2-配置Server"><a href="#6-2-配置Server" class="headerlink" title="6.2 配置Server"></a>6.2 配置Server</h2><ul>
<li><p>生成Server密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server_key.pem 2048</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成Server CSR<br>需要用到密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server_key.pem -out server_csr.pem</span><br><span class="line">...</span><br><span class="line">Country Name (2 letter code) [AU]:CN</span><br><span class="line">State or Province Name (full name) [Some-State]:GD</span><br><span class="line">Locality Name (eg, city) []:SZ</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:COMPANY</span><br><span class="line">Organizational Unit Name (eg, section) []:IT_SECTION</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:your.domain.com</span><br><span class="line">Email Address []:</span><br><span class="line"></span><br><span class="line">Please enter the following &apos;extra&apos; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-3-证书签名"><a href="#6-3-证书签名" class="headerlink" title="6.3 证书签名"></a>6.3 证书签名</h2><p>把上一步的server_csr.pem发给CA机器，在CA机器上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -in server_csr.pem -out server_crt.pem</span><br></pre></td></tr></table></figure></p>
<h2 id="6-4-完成"><a href="#6-4-完成" class="headerlink" title="6.4 完成"></a>6.4 完成</h2><p>Server端持有: 密钥server_key.pem、证书server_crt.pem<br>Client端持有: CA的根证书cacert.pem</p>
<p>双方即可进行ssl/tls握手通信</p>
<h1 id="7-ssl-tls双向校验"><a href="#7-ssl-tls双向校验" class="headerlink" title="7. ssl/tls双向校验"></a>7. ssl/tls双向校验</h1><p>因为在做gRPC鉴权的时候，我们需要的Server端对Client进行身份鉴权，于是发现ssl/tls是支持双向鉴权。<br>简单来说就是，除了Client端对Server端进行证书鉴权，Server端也会要求对Client进行证书鉴权。</p>
<p>握手过程如下，加粗的步骤是新增的。</p>
<ul>
<li>Client端发送ClientHello给Server端。包含协议版本、一个随机数(Random1)、支持的加密算法、压缩算法等。</li>
<li>Server端发送ServerHello给Client端。包含协议版本的确认、一个随机数(Random2)、确认的加密算法、压缩算法等。</li>
<li>Server端发送Certificate(证书)给Client端。</li>
<li><strong><strong>Server端发送Certificate Request给Client端，要求Client端提供证书。</strong></strong></li>
<li>Server端发送ServerHelloDone给Client端。</li>
<li><strong><strong>Client端发送Certificate给Server端。</strong></strong></li>
<li>Client端发送ClientKeyExchange给Server端。包含随机数PreMasterSecret，并且PreMasterSecret要用证书的公钥进行加密。</li>
<li>Client和Server端用Random1、Random2、PreMasterSecret算出来MasterSecret，这个MasterSecret就是双方约定的加密传输的对称秘钥，并且使用之前协商的加密算法，进行后续的数据交互。</li>
</ul>
<p>服务器拿到Client端的Certificate，进行类似Client端对Server端的Certificate校验过程，这样就实现了双向校验。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/11/23/ssl-tls/" data-id="ckluhuog2000l5sp3tmuaatzp" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/security/">security</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ssl-tls/">ssl/tls</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-udp-size" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/14/udp-size/" class="article-date">
  <time datetime="2016-11-14T11:51:27.000Z" itemprop="datePublished">2016-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/14/udp-size/">UDP package size</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近研究了一下udp相关的东西，做下笔记。<br>这里有相关的<a href="https://www.github.com/anticpp/experiments" target="_blank" rel="external">测试代码</a>。</p>
<h1 id="udp包一般多少适合"><a href="#udp包一般多少适合" class="headerlink" title="udp包一般多少适合"></a>udp包一般多少适合</h1><p>协议层的限制，理论上我们可以发送接收65535(0xFFFF)大小的udp包。为了避免IP层分片，udp包在ethernet上一般不超过1472(1500-20-8)，1500为ethernet的链路MTU。<br>实际上很多应用（例如DNS）的udp包都不超过512，为什么呢？</p>
<p>这是Stack Overflow上面的一句话<br>    The maximum safe UDP payload is 508 bytes. This is a packet size of 576, minus the maximum 60-byte IP header and the 8-byte UDP header. Any UDP payload this size or smaller is guaranteed to be deliverable over IP (though not guaranteed to be delivered). Anything larger is allowed to be outright dropped by any router for any reason.<br>按照字面理解的意思是，大于576的udp包在路由链路保证不了一定传输，难道是路由器的实现潜规则？</p>
<ul>
<li>更新At 2016-11-14</li>
</ul>
<p>RFC的IPV4标准里面有定义。</p>
<p>RFC 791 excerpt:<br>…<br>All hosts must be prepared to accept datagrams of up to 576 octets ( whether they arrive whole or in fragments ). It is recommended that hosts only send datagrams larger than 576 octets if they have assurance that the destination is prepared to accept the larger datagrams.<br>The number 576 is selected to allow a reasonable sized data block to be transmitted in addition to the required header information. For example, this size allows a data block of 512 octets plus 64 header octets to fit in a datagram. The maximal internet header is 60 octets, and a typical internet header is 20 octets, allowing a margin for headers of higher level protocols.<br>…</p>
<p>既然这样，另外一个问题来了，为什么TCP的MSS一般不受这个限制。<br>是因为TCP有做链路MTU探测，以及稳定的重传机制吗？</p>
<h1 id="udp-socket缓冲区"><a href="#udp-socket缓冲区" class="headerlink" title="udp socket缓冲区"></a>udp socket缓冲区</h1><ol>
<li>发送缓冲区</li>
</ol>
<p>经常有一个误解是udp没有发送缓冲区，实际udp也有发送缓冲区。只不过udp并不是流协议，发送缓冲区只会缓存一个包，然后立刻就被拷贝到内核协议栈。<br>如果发送一个超过缓冲区大小的udp包，大多数的实现是直接丢弃。</p>
<ol start="2">
<li>接收缓冲区</li>
</ol>
<p>接收缓冲区跟发送缓冲区有点不一样，所有的udp包会按照先后顺序缓存，应用层每次读会返回最早的包。实际上接收缓冲区就是FIFO队列。<br>如果接收缓冲区大小不够，大多数的实现是直接丢弃整个包。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/11/14/udp-size/" data-id="ckluhuofz000h5sp3gn1mcizu" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/network/">network</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ffmpeg" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/31/ffmpeg/" class="article-date">
  <time datetime="2016-03-31T13:05:06.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/ffmpeg/">FFmpeg</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ffmpeg使用"><a href="#ffmpeg使用" class="headerlink" title="ffmpeg使用"></a>ffmpeg使用</h1><h1 id="发布rtmp流"><a href="#发布rtmp流" class="headerlink" title="发布rtmp流"></a>发布rtmp流</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loglevel verbose -re -i test.flv -vcodec libx264  -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1 -f flv &apos;rtmp://10.10.159.119:1935/app1/2&apos;</span><br></pre></td></tr></table></figure>
<h1 id="ffmpeg安装"><a href="#ffmpeg安装" class="headerlink" title="ffmpeg安装"></a>ffmpeg安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-libmp3lame --enable-libx264 --enable-libfdk-aac --enable-gpl --extra-cflags=-I/usr/local/include --extra-ldflags=-L/usr/local/lib --extra-libs=-ldl --enable-nonfree</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/03/31/ffmpeg/" data-id="ckluhuofs00055sp34ybrrj5p" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/media/">media</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python-gevent-vs-go-coroutine" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/python-gevent-vs-go-coroutine/" class="article-date">
  <time datetime="2016-03-15T02:26:39.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/python-gevent-vs-go-coroutine/">python gevent VS go coroutine</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>针对python-threading、python-gevent和go-coroutine进行压测对比</p>
<h2 id="压测环境"><a href="#压测环境" class="headerlink" title="压测环境"></a>压测环境</h2><ul>
<li>压测机器是我的一台阿里云ECS机器</li>
<li>CPU x86_64 单核</li>
<li>内存 1G</li>
<li>操作系统Linux iZ94mudtv23Z 2.6.32-431.23.3.el6.x86_64 Centos 6.5</li>
<li>python 2.7</li>
<li>go 1.5.1</li>
</ul>
<h2 id="压测模型"><a href="#压测模型" class="headerlink" title="压测模型"></a>压测模型</h2><ul>
<li>测试不同并发上下文情况下，进程占用内存、CPU的情况</li>
<li>并发数由1000逐步递增到50000</li>
</ul>
<h2 id="压测数据"><a href="#压测数据" class="headerlink" title="压测数据"></a>压测数据</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><img src="/images/bench_vmem.png" alt="bench_vmem"></p>
<h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p><img src="/images/bench_mem.png" alt="bench_mem"></p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img src="/images/bench_cpu.png" alt="bench_cpu"></p>
<h2 id="压测结论"><a href="#压测结论" class="headerlink" title="压测结论"></a>压测结论</h2><ul>
<li>总体性能比较go-coroutine &gt; python-gevent &gt; python-threading</li>
<li>python-threading基本到15000并发数就上不去，可能是系统资源已经到了瓶颈</li>
<li>python-gevent在并发数较小时表现不错，随着并发数上涨，内存和CPU的增长也较快</li>
<li>python-gevent一开始就吃虚拟内存比较多</li>
<li>go-coroutine性能表现出色，随着并发数上涨，内存和CPU占用都维持在比较平稳的水平</li>
<li>总的来说不管是python-gevent还是go-coroutine，在用户态进行的context调度，比内核的threading消耗小很多</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><a href="https://github.com/anticpp/coroutine_benchmark" target="_blank" rel="external">github代码</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/03/15/python-gevent-vs-go-coroutine/" data-id="ckluhuofx000c5sp3w6fdygjc" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/programing-lanuage/">programing lanuage</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/">python</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/IP/">IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dht/">dht</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/go/">go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/media/">media</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meeting/">meeting</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mq/">mq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/network/">network</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openssl/">openssl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/p2p/">p2p</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programing-lanuage/">programing lanuage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/security/">security</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ssl-tls/">ssl/tls</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tools/">tools</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/IP/" style="font-size: 10px;">IP</a> <a href="/tags/dht/" style="font-size: 10px;">dht</a> <a href="/tags/go/" style="font-size: 20px;">go</a> <a href="/tags/media/" style="font-size: 10px;">media</a> <a href="/tags/meeting/" style="font-size: 10px;">meeting</a> <a href="/tags/mq/" style="font-size: 10px;">mq</a> <a href="/tags/network/" style="font-size: 15px;">network</a> <a href="/tags/openssl/" style="font-size: 10px;">openssl</a> <a href="/tags/p2p/" style="font-size: 10px;">p2p</a> <a href="/tags/programing-lanuage/" style="font-size: 15px;">programing lanuage</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/security/" style="font-size: 10px;">security</a> <a href="/tags/ssl-tls/" style="font-size: 10px;">ssl/tls</a> <a href="/tags/tools/" style="font-size: 20px;">tools</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/04/message-queue/">Message queue</a>
          </li>
        
          <li>
            <a href="/2018/05/11/gopher-2018/">Gopher 2018 shanghai memo</a>
          </li>
        
          <li>
            <a href="/2018/05/05/cpp-virtual-vs-go-interface/">Go interface internal</a>
          </li>
        
          <li>
            <a href="/2018/05/03/private-addr/">IPv4 private address</a>
          </li>
        
          <li>
            <a href="/2018/04/17/dht/">DHT</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 supergui@live.cn<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>