<!doctype html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="旗帜鲜明的站在C++的对立面">
<meta property="og:type" content="website">
<meta property="og:title" content="supergui">
<meta property="og:url" content="http://anticpp.github.io/index.html">
<meta property="og:site_name" content="supergui">
<meta property="og:description" content="旗帜鲜明的站在C++的对立面">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="supergui">
<meta name="twitter:description" content="旗帜鲜明的站在C++的对立面">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://anticpp.github.io/"/>





  <title> supergui </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">supergui</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">迁于乔木，出自幽谷</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://anticpp.github.io/2018/04/17/dht/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="supergui@live.cn">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="supergui">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="supergui" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/04/17/dht/" itemprop="url">
                  DHT
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-17T21:03:24+08:00">
                2018-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>222BT作为历史上最成功的P2P文件系统，已经在全球实现了彻底的去中心化。BT的P2P网络，不依赖任何机构或者中心依然能够很好的运行。<br>这里面，最关键的设计是引入了DHT。这里我们主要介绍一下为什么要引入DHT，以及DHT的基本原理。</p>
<p>BT作为一种P2P系统，面临<strong><em>资源索引</em></strong>问题，简单来说<strong><em>资源索引</em></strong>维护资源(resource)当前有哪些节点(peer)也在同时下载的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">res0 -&gt; peerA,peerB,...</span><br><span class="line">res1 -&gt; peerC,peerD,...</span><br><span class="line"></span><br><span class="line">                         ------------------------------</span><br><span class="line">              Index ---&gt; | res0 | res1 | ...          |</span><br><span class="line">                         ------------------------------</span><br><span class="line">                            |      |</span><br><span class="line">                           \|/    \|/</span><br><span class="line">                         ------- -------</span><br><span class="line">                         |peerA| |peerC|</span><br><span class="line">                         ------- -------</span><br><span class="line">                            |      |</span><br><span class="line">                         ------- -------</span><br><span class="line">                         |peerB| |peerD|</span><br><span class="line">                         ------- -------</span><br></pre></td></tr></table></figure>
<h2 id="2-中心化"><a href="#2-中心化" class="headerlink" title="2. 中心化"></a>2. 中心化</h2><p>实际上BT下载的传输本身是去中心化的，我们每一个peer会同时从网络上搜索到的其它peer进行数据传输。<br>但是<strong><em>资源索引</em></strong>一开始还是属于中心化的解决方案，就是Tracker。虽然网络上有很多提供Tracker的服务，每一个客户端也可以设置若干个Tracker，但是Tracker依然是一个中心化的服务。</p>
<p>Tracker提供了上报和查询服务，如下图：正在下载某一个资源(res)的BT客户端peer2把资源上报给Tracker。下载资源的BT客户端(peer1)可以到Tracker查询时下载这个资源的peer2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">           --------------    -----------------------------------</span><br><span class="line">      |---&gt;| Tracker    | -- |           Index                 |</span><br><span class="line">      |    --------------    -----------------------------------</span><br><span class="line">      |     |         /|\   </span><br><span class="line">      |     |          |</span><br><span class="line">      |     |          |</span><br><span class="line">query |     |resp      |</span><br><span class="line">      |     |(peer2)   |</span><br><span class="line">      |     |          |    report res</span><br><span class="line">      |     |          |----------------</span><br><span class="line">      |    \|/                         |</span><br><span class="line">   -----------                     ---------</span><br><span class="line">   |  peer1  |                     | peer2 |</span><br><span class="line">   -----------                     ---------</span><br></pre></td></tr></table></figure>
<p>Tracker提供了一种简单高效的方案，解决了资源索引的问题。缺点是一旦Tracker不可用，BT的P2P网络也就随之瘫痪(我们可以参考海盗湾事件)。这是所有中心化服务必将面临的问题，为了让整个P2P网络更加健壮，需要探索一个去中心化的实现。</p>
<h2 id="3-去中心化"><a href="#3-去中心化" class="headerlink" title="3. 去中心化"></a>3. 去中心化</h2><p>考虑没有中心化的Tracker，我们需要一个去中心化的方式，把资源的索引存储到全网的节点，并且能高效的查询。</p>
<h3 id="3-1-全量"><a href="#3-1-全量" class="headerlink" title="3.1 全量"></a>3.1 全量</h3><p>最简单的办法，就是让每一个Node(节点)都维护一个全量的索引，相当于每个Node都是一个Tracker节点。</p>
<blockquote>
<p>注意：我们需要区分一下Node和Peer的概念，以下是DHT的papper的描述<br>A “peer” is a client/server listening on a TCP port that implements the BitTorrent protocol. A “node” is a client/server listening on a UDP port implementing the distributed hash table protocol. </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--------------    -----------------------------------</span><br><span class="line">| Node0      | -- |           Index                 |</span><br><span class="line">--------------    -----------------------------------</span><br><span class="line"></span><br><span class="line">--------------    -----------------------------------</span><br><span class="line">| Node1      | -- |           Index                 |</span><br><span class="line">--------------    -----------------------------------</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">--------------    -----------------------------------</span><br><span class="line">| NodeN      | -- |           Index                 |</span><br><span class="line">--------------    -----------------------------------</span><br></pre></td></tr></table></figure>
<p>这种方案有几个明显的问题</p>
<ol>
<li>每个索引的变更需要扩散到全网，效率太差</li>
<li>海量的索引，每个单点都需要全量存储，代价太大</li>
</ol>
<h3 id="3-2-Sharding"><a href="#3-2-Sharding" class="headerlink" title="3.2 Sharding"></a>3.2 Sharding</h3><p>基本的思路是，我们需要把索引数据按照<strong><em>一定规则</em></strong>分布(sharding)到全网的节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    -----------       -----------     -----------                   -----------</span><br><span class="line">    |  Node0  |       |  Node1  |     |  Node2  |       ...         |  NodeN  |</span><br><span class="line">    -----------       -----------     -----------                   -----------</span><br><span class="line">       /|\                 /|\            /|\                            /|\</span><br><span class="line">        |--------           |              |                              |</span><br><span class="line">                 |          |              |                              |</span><br><span class="line">            -----------------------------------------------------------------------</span><br><span class="line">Index ----&gt; |  shard0    |  shard1    |   shard2     |  ...      |    shardN      |</span><br><span class="line">            -----------------------------------------------------------------------</span><br></pre></td></tr></table></figure>
<p>一致性Hash是一种常用的办法，首先把Node散列(hash<nodeid>)到一个整数的空间，这样每一个Node负责一个范围段的索引。<br>同样，我们可以把资源也计算一个整数的hash。<br>例如，NodeA负责范围<code>[i, j)</code>的范围，那么如果索引按照分布规则在范围内，那么该索引就由NodeA负责存储。</nodeid></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// NodeA covers [i, j).</span><br><span class="line">// Use hash(resource) to caculate resource.</span><br><span class="line">if i &lt; hash(resource) &lt; j &#123;</span><br><span class="line">    store(resource, NodeA) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里盗用一个网上的一致性Hash图片，具体的算法这里就不重复介绍了。</p>
<p><img src="/images/dht-constant-hash.jpg" alt=""></p>
<p>一致性Hash解决了sharding的问题，但是一致性Hash引入了Hash环状态。在系统中如何维护Hash状态数据，跟如何维护资源索引面临一样的问题。</p>
<p>我们需要彻底解决状态数据的问题，才能真正实现去中心化。</p>
<h2 id="4-DHT"><a href="#4-DHT" class="headerlink" title="4. DHT"></a>4. DHT</h2><p>DHT(Distributed Hash Table)，就是分布式Hash table。实际上也是Sharding的一种实现方法，DHT可以看作是一致性Hash的基础上的改进。</p>
<p>一致性Hash算法的问题是Hash环的状态数据，只要我们能设计出一种关于索引分布规则的去中心化的<strong><em>共识机制</em></strong>，我们并不需要去维护一个Hash环。DHT本质上设计了这样一种去中心化的<strong><em>共识机制</em></strong>。</p>
<p>关于DHT的比较完整的介绍，可以参考<a href="http://www.bittorrent.org/beps/bep_0005.html" target="_blank" rel="external">DHT Protocol</a>。</p>
<h3 id="4-1-Hash"><a href="#4-1-Hash" class="headerlink" title="4.1 Hash"></a>4.1 Hash</h3><p>DHT网络中每个节点的NodeID就是一个hash值，每个资源也有一个hash。</p>
<h3 id="4-2-距离"><a href="#4-2-距离" class="headerlink" title="4.2 距离"></a>4.2 距离</h3><p>用来计算2个hash的距离，Node和Node之间可以有距离，Node和资源之间也可以有距离。要注意的是，这个距离并不是实际意义上的距离，只是一个算法上的需要。</p>
<h3 id="4-3-Routing-table"><a href="#4-3-Routing-table" class="headerlink" title="4.3 Routing table"></a>4.3 Routing table</h3><p>DHT网络中每个Node都维护一个Routing table（路由表），保存它和网络中一小部分节点信息。每一个节点，都能够提供查询接口，并且能够返回距离目标hash更近的新节点。这样，可以通过一个<strong><em>收敛的递归查询</em></strong>，不断的趋近目标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">                   ---------------------------------------------</span><br><span class="line">Routing table --&gt;  | NodeInfo0 | NodeInfo1 | ...   | NodeInfoN |</span><br><span class="line">                   ---------------------------------------------</span><br></pre></td></tr></table></figure>
<p>这个过程实际上是一个Peer Routing的过程，<a href="https://github.com/libp2p/specs/blob/master/4-architecture.md#41-peer-routing" target="_blank" rel="external">IPFS peer routing</a>对这个概念有比较好的总结。</p>
<p>一个典型的Query Resource过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 ) client需要查找目标资源hash，先到Node0进行查询。</span><br><span class="line">2 ) 如果Node0本地有这个hash的索引，则返回结果</span><br><span class="line">3 ) 如果Node0本地没有这个hash的索引，Node0从自己的Routing table查找离目标hash更近的节点，例如Node1和Node2</span><br><span class="line">4 ) client对Node1和Node2重复过程1的查询，直到有查询到有结果</span><br><span class="line"></span><br><span class="line">           1) query hash       -----------</span><br><span class="line">client  --------------------&gt;  |         |</span><br><span class="line">        &lt;-------------------   |  Node0  |</span><br><span class="line">           2 ) Resource        |         |</span><br><span class="line">           3 ) Node1,Node2     -----------</span><br><span class="line"></span><br><span class="line">           4 ) query hash      -----------</span><br><span class="line">        --------------------&gt;  |  Node1  |</span><br><span class="line">                               -----------</span><br><span class="line"></span><br><span class="line">           4 ) query hash      -----------</span><br><span class="line">        --------------------&gt;  |  Node2  |</span><br><span class="line">                               -----------</span><br></pre></td></tr></table></figure></p>
<h2 id="5-Kademlia"><a href="#5-Kademlia" class="headerlink" title="5. Kademlia"></a>5. Kademlia</h2><p>DHT有很多不同的实现，这里主要介绍Kademlia，一般我们叫KAD DHT。<br>KAD使用k-bucket(k桶)实现Routing table，能实现log2(N)的查询效率。假设1000000节点的规模的网络，可以最多20次查询能够完成全网节点的查询。</p>
<h3 id="5-1-距离"><a href="#5-1-距离" class="headerlink" title="5.1 距离"></a>5.1 距离</h3><p>KAD使用XOR(按位异或)对两个hash进行距离计算，为什么要使用异或？我们后面结合k桶可以看到，这是经过精心设计的算法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distance(A, B) = A xor B</span><br></pre></td></tr></table></figure>
<h3 id="5-2-Routing-table"><a href="#5-2-Routing-table" class="headerlink" title="5.2 Routing table"></a>5.2 Routing table</h3><p>KAD使用k桶(k-bucket)实现一个Routing table，其实就是一个hash table，只是每一个bucket的大小不超过k(目的是控制Routing table的大小)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://anticpp.github.io/2016/11/24/Openssl常用工具/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="supergui@live.cn">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="supergui">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="supergui" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/Openssl常用工具/" itemprop="url">
                  Openssl常用工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-24T17:34:05+08:00">
                2016-11-24
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-生成rsa密钥文件"><a href="#1-生成rsa密钥文件" class="headerlink" title="1. 生成rsa密钥文件"></a>1. 生成rsa密钥文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/cakey.pem</span><br></pre></td></tr></table></figure>
<h1 id="2-查看密钥文件"><a href="#2-查看密钥文件" class="headerlink" title="2. 查看密钥文件"></a>2. 查看密钥文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa -noout -text -in private/cakey.pem</span><br></pre></td></tr></table></figure>
<h1 id="3-生成CSR"><a href="#3-生成CSR" class="headerlink" title="3. 生成CSR"></a>3. 生成CSR</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server_key.pem -out server_csr.pem</span><br></pre></td></tr></table></figure>
<pre><code>依赖：密钥文件server_key.pem
</code></pre><h1 id="4-查看CSR信息"><a href="#4-查看CSR信息" class="headerlink" title="4. 查看CSR信息"></a>4. 查看CSR信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -noout -text -in server_csr.pem</span><br></pre></td></tr></table></figure>
<h1 id="5-生成证书"><a href="#5-生成证书" class="headerlink" title="5. 生成证书"></a>5. 生成证书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key private/cakey.pem -out cacert.pem</span><br></pre></td></tr></table></figure>
<pre><code>依赖：密钥文件cakey.pem
</code></pre><h1 id="6-对CSR签名，生成证书"><a href="#6-对CSR签名，生成证书" class="headerlink" title="6. 对CSR签名，生成证书"></a>6. 对CSR签名，生成证书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -in server_csr.pem -out server_crt.pem</span><br></pre></td></tr></table></figure>
<h1 id="6-查看证书"><a href="#6-查看证书" class="headerlink" title="6. 查看证书"></a>6. 查看证书</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -noout -text -in server_crt.pem</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://anticpp.github.io/2016/11/23/SSL-TLS/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="supergui@live.cn">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="supergui">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="supergui" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/23/SSL-TLS/" itemprop="url">
                  SSL/TLS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-23T14:12:57+08:00">
                2016-11-23
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近在折腾Microservice的gRPC鉴权问题，顺带梳理了下ssl/xls的原理。<br>以前没有特别深究过里面的问题，最近大概都算理清楚了，这里Mark也下。</p>
<h1 id="1-ssl-tls"><a href="#1-ssl-tls" class="headerlink" title="1. ssl/tls"></a>1. ssl/tls</h1><p>ssl/tls是一套基于非对称加密的安全协议，实际上ssl和tls是两个版本，大多数情况下这两个名词一起被提到，可以理解为tls是ssl的升级版本。</p>
<h1 id="2-https"><a href="#2-https" class="headerlink" title="2. https"></a>2. https</h1><p>其实https是泛指http over secure，是在http协议之上增加的安全协议。当然，也有人会把它理解为http over ssl或者http over tls。<br>一般我们提到https都会默认提到ssl/tls，是因为ssl/tls在当前是最成熟的应用到https上。</p>
<h1 id="3-ssl-tls握手"><a href="#3-ssl-tls握手" class="headerlink" title="3. ssl/tls握手"></a>3. ssl/tls握手</h1><p>实际上https在安全机制上是做了两个事情，我们常常也会忽略。</p>
<ul>
<li>加密传输</li>
<li>证书校验</li>
</ul>
<p>握手的过程大概如下</p>
<ul>
<li>Client端发送ClientHello给Server端。包含协议版本、一个随机数(Random1)、支持的加密算法、压缩算法等。</li>
<li>Server端发送ServerHello给Client端。包含协议版本的确认、一个随机数(Random2)、确认的加密算法、压缩算法等。</li>
<li>Server端发送Certificate(证书)给Client端。</li>
<li>Server端发送ServerHelloDone给Client端。</li>
<li>Client端发送ClientKeyExchange给Server端。包含一个随机数PreMasterSecret，并且PreMasterSecret要用证书里面的公钥进行加密。</li>
<li><p>Server端用自己的私钥把PreMasterSecret解开。Client和Server都用Random1、Random2、PreMasterSecret算出来MasterSecret，这个MasterSecret就是双方约定的加密传输的对称秘钥，并且使用之前协商的加密算法，进行后续的数据交互。</p>
<p>  注意：</p>
<ol>
<li>Server端所持有的私钥和公钥（在Certificate里面），并没有参与Certificate校验的过程，只是用来做最后一个随机数PreMasterSecret的加密保障。</li>
<li>这个过程并没有描述Certificate在Client端是怎么验证的，也就是Client根据什么确认Server的签名信息。</li>
</ol>
</li>
</ul>
<h1 id="4-ssl-tls加密传输"><a href="#4-ssl-tls加密传输" class="headerlink" title="4. ssl/tls加密传输"></a>4. ssl/tls加密传输</h1><p>加密传输是https的最重要特性，保证了所有网络上的数据不会被明文探测。整个握手过程实际上是明文的，生成MasterSecret的前面两个随机数也是明文。实际最终保证安全性的关键在于，PreMasterSecret这个随机数的安全性。而这个随机数的安全性是建立在非对称加密的安全性上面。</p>
<h1 id="5-ssl-tls证书校验"><a href="#5-ssl-tls证书校验" class="headerlink" title="5. ssl/tls证书校验"></a>5. ssl/tls证书校验</h1><h2 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h2><p>证书签名的基本原理很简单，一般是利用非对称加密算法。非对秘钥一般成对出现（最常用的RSA），一个公钥，一个私钥。<br>公钥加密的信息，只有私钥能解开。同理，私钥加密的信息，只有公钥能解开。<br>例如：我用私钥加密一段内容，同时告诉对方我的公钥，对方如果可以用我的公钥解开我的内容，就可以证明这段信息是我的。这里面，被加密的内容就可以作为签名信息。</p>
<h2 id="5-2-关于CA-证书校验"><a href="#5-2-关于CA-证书校验" class="headerlink" title="5.2 关于CA/证书校验"></a>5.2 关于CA/证书校验</h2><p>ssl/tls的握手过程，往往容易忽略证书校验的过程，这个发生在握手的第3步，Server端发送证书给客户单之后，客户端是怎么验证证书的合法性呢？<br>握手的过程很简单，Server端的一组非对称秘钥，并没有参与到任何证书校验的环节，只是用来做了最后一个随机数PreMasterSecret的安全保障。</p>
<p>实际上我们Server的一对秘钥，并不是用来做证书校验，证书校验是通过另外一组非对称秘钥来保证。<br>这里就要提到<strong><em><a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="external">CA(Certificate Authority)</a></em></strong>，CA是一个权威机构，主要负责证书的签名、发放、校验等职责。<br>主要逻辑参考这个图</p>
<p><img src="/images/tls_certification.png" alt="certification_flow"></p>
<ol>
<li>CA本身有自己的一套根密钥(cakey.pem)、根证书(cacert.pem一般包含了证书信息、对应的公钥信息等)</li>
<li>Server生成自己的密钥(server_key.pem)和证书签名请求CSR(server_csr.pem)</li>
<li><p>Server拿server_csr.pem到CA进行签名，得到server_crt.pem，即最终的证书。CA签名的过程，可以简单理解为用cakey.pem对server_csr.pem增加一段加密的签名信息。这段签名信息，只有CA的公钥（公钥信息在cacert.pem可以得到）可以解开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(cakey.pem, server_csr.pem) = server_crt.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>Client端（一般是浏览器）会内置了CA的根证书(cacert.pem)。在ssl/tls握手的第3步，Client拿到Server的Certificate（这个其实就是server_crt.pem），就可以根据CA的根证书对Certificate进行验证。</p>
</li>
</ol>
<p>所以，最终证书的安全性建立在Client端的CA根证书的安全性。</p>
<pre><code>Note: 怎么保证Client端CA证书的安全性？
</code></pre><h2 id="5-3-为什么要给钱"><a href="#5-3-为什么要给钱" class="headerlink" title="5.3 为什么要给钱"></a>5.3 为什么要给钱</h2><p>正常的网站，为了做网站的证书签名，都需要找到权威的CA机构进行证书签名，而CA对这块都是要付费的。<br>那问题是，我们为什么非得找这些CA付费，自己随便搞一个假的CA进行对自己的证书进行签名不就行了吗。<br>其实也有人这样干，大家可以参考万恶的<a href="http://www.12306.cn" target="_blank" rel="external">http://12306.cn</a>。对，就是那个全世界最大的电商网站。<br>例如用Chrome访问都会提示证书不安全，因为他们并没有找权威CA进行证书签名。<br><img src="/images/https_error.png" alt="https_error"><br>CA的权威性，是建立在行业标准之上的存在，所以对浏览器厂商也会遵循这些行业标准。也就是，这些浏览器都会内置权威的CA的根证书。为了让浏览器能显示你是认证的网站 ，必须找权威的CA机构，给钱、签名。</p>
<h1 id="6-Openssl自建CA、Server数字证书"><a href="#6-Openssl自建CA、Server数字证书" class="headerlink" title="6. Openssl自建CA、Server数字证书"></a>6. Openssl自建CA、Server数字证书</h1><p>恩，为什么要自建CA呢。<br>上面说了，ssl/tls实际上是做了两个事情，加密传输和证书验证。<br>这两个事情，其实不太相关。<br>证书验证，大部分场景是在网站浏览器端，所以网站必须给权威的CA机构付费。<br>但是，如非浏览器应用，我们只是想利用xls/tls加密传输。<br>我们就完全有理由自己搞私有的CA，自己给自己发证书了。</p>
<p>Openssl工具提供了一整套完整的命令行工具，大概流程如下<br>主要做几件事情</p>
<ol>
<li>配置自己的CA</li>
<li>生成Server的密钥，CSR</li>
<li>用CSR到CA签名，生成CRT，也就是证书</li>
</ol>
<pre><code>CSR: Certificate Signing Request，证书签名请求
CRT: Certificate，证书
</code></pre><h2 id="6-1-配置CA"><a href="#6-1-配置CA" class="headerlink" title="6.1 配置CA"></a>6.1 配置CA</h2><p>如果安装了Openssl，默认的路径在/etc/pki/。<br>配置文件路径在tls/openssl.cnf，基本的配置可以不用改。<br>可以简单关注一下policy_match相关的配置，这里配置了对不同证书信息是否进行校验。</p>
<ul>
<li><p>进入CA目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd CA/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建两个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch index.txt serial</span><br><span class="line">echo 01 &gt; serial</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建根密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/cakey.pem 2048</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建根证书<br>需要用到密钥 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key private/cakey.pem -out cacert.pem</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-2-配置Server"><a href="#6-2-配置Server" class="headerlink" title="6.2 配置Server"></a>6.2 配置Server</h2><ul>
<li><p>生成Server密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server_key.pem 2048</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成Server CSR<br>需要用到密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server_key.pem -out server_csr.pem</span><br><span class="line">...</span><br><span class="line">Country Name (2 letter code) [AU]:CN</span><br><span class="line">State or Province Name (full name) [Some-State]:GD</span><br><span class="line">Locality Name (eg, city) []:SZ</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:COMPANY</span><br><span class="line">Organizational Unit Name (eg, section) []:IT_SECTION</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:your.domain.com</span><br><span class="line">Email Address []:</span><br><span class="line"></span><br><span class="line">Please enter the following &apos;extra&apos; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-3-证书签名"><a href="#6-3-证书签名" class="headerlink" title="6.3 证书签名"></a>6.3 证书签名</h2><p>把上一步的server_csr.pem发给CA机器，在CA机器上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -in server_csr.pem -out server_crt.pem</span><br></pre></td></tr></table></figure></p>
<h2 id="6-4-完成"><a href="#6-4-完成" class="headerlink" title="6.4 完成"></a>6.4 完成</h2><p>Server端持有: 密钥server_key.pem、证书server_crt.pem<br>Client端持有: CA的根证书cacert.pem</p>
<p>双方即可进行ssl/tls握手通信</p>
<h1 id="7-ssl-tls双向校验"><a href="#7-ssl-tls双向校验" class="headerlink" title="7. ssl/tls双向校验"></a>7. ssl/tls双向校验</h1><p>因为在做gRPC鉴权的时候，我们需要的Server端对Client进行身份鉴权，于是发现ssl/tls是支持双向鉴权。<br>简单来说就是，除了Client端对Server端进行证书鉴权，Server端也会要求对Client进行证书鉴权。</p>
<p>握手过程如下，加粗的步骤是新增的。</p>
<ul>
<li>Client端发送ClientHello给Server端。包含协议版本、一个随机数(Random1)、支持的加密算法、压缩算法等。</li>
<li>Server端发送ServerHello给Client端。包含协议版本的确认、一个随机数(Random2)、确认的加密算法、压缩算法等。</li>
<li>Server端发送Certificate(证书)给Client端。</li>
<li><strong><strong>Server端发送Certificate Request给Client端，要求Client端提供证书。</strong></strong></li>
<li>Server端发送ServerHelloDone给Client端。</li>
<li><strong><strong>Client端发送Certificate给Server端。</strong></strong></li>
<li>Client端发送ClientKeyExchange给Server端。包含随机数PreMasterSecret，并且PreMasterSecret要用证书的公钥进行加密。</li>
<li>Client和Server端用Random1、Random2、PreMasterSecret算出来MasterSecret，这个MasterSecret就是双方约定的加密传输的对称秘钥，并且使用之前协商的加密算法，进行后续的数据交互。</li>
</ul>
<p>服务器拿到Client端的Certificate，进行类似Client端对Server端的Certificate校验过程，这样就实现了双向校验。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://anticpp.github.io/2016/11/14/udp包的问题/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="supergui@live.cn">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="supergui">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="supergui" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/14/udp包的问题/" itemprop="url">
                  udp包的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-14T19:51:27+08:00">
                2016-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近研究了一下udp相关的东西，做下笔记。<br>这里有相关的<a href="https://www.github.com/anticpp/experiments" target="_blank" rel="external">测试代码</a>。</p>
<h1 id="udp包一般多少适合"><a href="#udp包一般多少适合" class="headerlink" title="udp包一般多少适合"></a>udp包一般多少适合</h1><p>协议层的限制，理论上我们可以发送接收65535(0xFFFF)大小的udp包。为了避免IP层分片，udp包在ethernet上一般不超过1472(1500-20-8)，1500为ethernet的链路MTU。<br>实际上很多应用（例如DNS）的udp包都不超过512，为什么呢？</p>
<p>这是Stack Overflow上面的一句话<br>    The maximum safe UDP payload is 508 bytes. This is a packet size of 576, minus the maximum 60-byte IP header and the 8-byte UDP header. Any UDP payload this size or smaller is guaranteed to be deliverable over IP (though not guaranteed to be delivered). Anything larger is allowed to be outright dropped by any router for any reason.<br>按照字面理解的意思是，大于576的udp包在路由链路保证不了一定传输，难道是路由器的实现潜规则？</p>
<ul>
<li>更新At 2016-11-14<br>似乎RFC的IPV4标准里面有定义。</li>
</ul>
<p>RFC 791 excerpt:<br>…<br>All hosts must be prepared to accept datagrams of up to 576 octets ( whether they arrive whole or in fragments ). It is recommended that hosts only send datagrams larger than 576 octets if they have assurance that the destination is prepared to accept the larger datagrams.<br>The number 576 is selected to allow a reasonable sized data block to be transmitted in addition to the required header information. For example, this size allows a data block of 512 octets plus 64 header octets to fit in a datagram. The maximal internet header is 60 octets, and a typical internet header is 20 octets, allowing a margin for headers of higher level protocols.<br>…</p>
<p>既然这样，另外一个问题来了，为什么TCP的MSS一般不受这个限制。<br>是因为TCP有做链路MTU探测，以及稳定的重传机制吗？</p>
<h1 id="udp-socket缓冲区"><a href="#udp-socket缓冲区" class="headerlink" title="udp socket缓冲区"></a>udp socket缓冲区</h1><ol>
<li><p>发送缓冲区<br>经常有一个误解是udp没有发送缓冲区，实际udp也有发送缓冲区。只不过udp并不是流协议，发送缓冲区只会缓存一个包，然后立刻就被拷贝到内核协议栈。<br>如果发送一个超过缓冲区大小的udp包，大多数的实现是直接丢弃。</p>
</li>
<li><p>接收缓冲区<br>接收缓冲区跟发送缓冲区有点不一样，所有的udp包会按照先后顺序缓存，应用层每次读会返回最早的包。实际上接收缓冲区就是FIFO队列。<br>如果接收缓冲区大小不够，大多数的实现是直接丢弃整个包。</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://anticpp.github.io/2016/03/31/ffmpeg/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="supergui@live.cn">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="supergui">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="supergui" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/31/ffmpeg/" itemprop="url">
                  ffmpeg
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-31T21:05:06+08:00">
                2016-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ffmpeg使用"><a href="#ffmpeg使用" class="headerlink" title="ffmpeg使用"></a>ffmpeg使用</h1><h1 id="发布rtmp流"><a href="#发布rtmp流" class="headerlink" title="发布rtmp流"></a>发布rtmp流</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loglevel verbose -re -i test.flv -vcodec libx264  -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1 -f flv &apos;rtmp://10.10.159.119:1935/app1/2&apos;</span><br></pre></td></tr></table></figure>
<h1 id="ffmpeg安装"><a href="#ffmpeg安装" class="headerlink" title="ffmpeg安装"></a>ffmpeg安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-libmp3lame --enable-libx264 --enable-libfdk-aac --enable-gpl --extra-cflags=-I/usr/local/include --extra-ldflags=-L/usr/local/lib --extra-libs=-ldl --enable-nonfree</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://anticpp.github.io/2016/03/15/python-gevent和go-coroutine对比/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="supergui@live.cn">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="supergui">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="supergui" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/15/python-gevent和go-coroutine对比/" itemprop="url">
                  python-gevent和go-coroutine对比
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-15T10:26:39+08:00">
                2016-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>针对python-threading、python-gevent和go-coroutine进行压测对比</p>
<h2 id="压测环境"><a href="#压测环境" class="headerlink" title="压测环境"></a>压测环境</h2><ul>
<li>压测机器是我的一台阿里云ECS机器</li>
<li>CPU x86_64 单核</li>
<li>内存 1G</li>
<li>操作系统Linux iZ94mudtv23Z 2.6.32-431.23.3.el6.x86_64 Centos 6.5</li>
<li>python 2.7</li>
<li>go 1.5.1</li>
</ul>
<h2 id="压测模型"><a href="#压测模型" class="headerlink" title="压测模型"></a>压测模型</h2><ul>
<li>测试不同并发上下文情况下，进程占用内存、CPU的情况</li>
<li>并发数由1000逐步递增到50000</li>
</ul>
<h2 id="压测数据"><a href="#压测数据" class="headerlink" title="压测数据"></a>压测数据</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><img src="/images/bench_vmem.png" alt="bench_vmem"></p>
<h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p><img src="/images/bench_mem.png" alt="bench_mem"></p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img src="/images/bench_cpu.png" alt="bench_cpu"></p>
<h2 id="压测结论"><a href="#压测结论" class="headerlink" title="压测结论"></a>压测结论</h2><ul>
<li>总体性能比较go-coroutine &gt; python-gevent &gt; python-threading</li>
<li>python-threading基本到15000并发数就上不去，可能是系统资源已经到了瓶颈</li>
<li>python-gevent在并发数较小时表现不错，随着并发数上涨，内存和CPU的增长也较快</li>
<li>python-gevent一开始就吃虚拟内存比较多</li>
<li>go-coroutine性能表现出色，随着并发数上涨，内存和CPU占用都维持在比较平稳的水平</li>
<li>总的来说不管是python-gevent还是go-coroutine，在用户态进行的context调度，比内核的threading消耗小很多</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><a href="https://github.com/anticpp/coroutine_benchmark" target="_blank" rel="external">github代码</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://anticpp.github.io/2016/02/29/hexo安装/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="supergui@live.cn">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="supergui">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="supergui" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/29/hexo安装/" itemprop="url">
                  hexo安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-29T19:58:22+08:00">
                2016-02-29
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>折腾了下hexo的环境，用来做自己的markdown博客还是相当不错，还支持github部署。这里讲一下怎么安装。</p>
<p><a href="https://hexo.io/" target="_blank" rel="external">hexo官网</a><br><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">hexo github地址</a></p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>hexo是基于nodejs的插件实现，需要先安装nodejs<br>安装办法参考<a href="http://nodejs.cn/" target="_blank" rel="external">nodejs官网</a>。</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><pre><code>npm install -g hexo
</code></pre><h2 id="初始化blog"><a href="#初始化blog" class="headerlink" title="初始化blog"></a>初始化blog</h2><p>例如我的博客目录在~/blog/，则cd到~目录执行初始化，如下</p>
<pre><code>cd ~
hexo init blog
cd blog
npm install
</code></pre><h2 id="启动hexo-server"><a href="#启动hexo-server" class="headerlink" title="启动hexo-server"></a>启动hexo-server</h2><pre><code>cd ~/blog/
hexo server
</code></pre><p>hexo会启动一个监听4000端口的http服务器，输出信息</p>
<pre><code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.
</code></pre><h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><pre><code>hexo generate
</code></pre><h2 id="本地查看"><a href="#本地查看" class="headerlink" title="本地查看"></a>本地查看</h2><p>在浏览器输入地址<code>http://localhost:4000/</code>，即可看到你的博客页面。</p>
<h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><pre><code>hexo new &quot;page1&quot;
</code></pre><h2 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a>github部署</h2><p><a href="https://pages.github.com/" target="_blank" rel="external">github page</a>是github提供的公开网页托管服务。可以把网页push到github仓库，然后可以通过公开域名访问。</p>
<p>hexo支持进行github page部署。具体步骤如下</p>
<ol>
<li><p>在你的github上面创建仓库，名字为’username’.github.io。<br> ‘username’为你的github账号。</p>
</li>
<li><p>配置_config.xml<br>例如我的github账号为anticpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:anticpp/anticpp.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署<br> hexo deploy</p>
</li>
</ol>
<p><code>note:</code><br><code>如果出现错误信息&#39;ERROR Deployer not found: git&#39;，尝试安装以下组件</code></p>
<pre><code>npm install hexo-deployer-git --save
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://anticpp.github.io/2016/02/29/ssh信任关系/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="supergui@live.cn">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="supergui">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="supergui" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/02/29/ssh信任关系/" itemprop="url">
                  ssh信任关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-02-29T19:26:15+08:00">
                2016-02-29
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>自动ssh登录，我写了一个autossh的工具。<br>有兴趣的朋友可以试试<a href="https://github.com/anticpp/autossh" target="_blank" rel="external">autossh</a></p>
</blockquote>
<blockquote>
<p>回到正题，A要ssh登陆到B，不想输入密码。可以在B建立一个对A的ssh信任关系即可。<br>ssh的信任关系是通过rsa实现，具体的操作步骤如下:</p>
</blockquote>
<h2 id="A机器生成rsa-key"><a href="#A机器生成rsa-key" class="headerlink" title="A机器生成rsa key"></a>A机器生成rsa key</h2><ul>
<li>进入~/.ssh/</li>
<li>运行ssh-keygen，所有的提示都默认回车即可</li>
<li>拷贝公钥，cat id_rsa.pub</li>
</ul>
<h2 id="B机器添加公钥"><a href="#B机器添加公钥" class="headerlink" title="B机器添加公钥"></a>B机器添加公钥</h2><ul>
<li>进入~/.ssh/</li>
<li>把A生成的公钥，添加到authorized_keys</li>
</ul>
<h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><ul>
<li>从A登陆B机器，无需密码</li>
</ul>
<p><code>注意:</code><br><code>非root账号的ssh信任关系一直都还不行，网上很多资料都说是文件权限问题，试了下都不行。</code><br><code>所以暂时未解，后面找到原因再跟进到文档。</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="supergui@live.cn" />
          <p class="site-author-name" itemprop="name">supergui@live.cn</p>
          <p class="site-description motion-element" itemprop="description">旗帜鲜明的站在C++的对立面</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">8</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">supergui@live.cn</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>
