<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tag: 技术 | supergui</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="旗帜鲜明的站在C++的对立面">
<meta property="og:type" content="website">
<meta property="og:title" content="supergui">
<meta property="og:url" content="http://anticpp.github.io/tags/技术/index.html">
<meta property="og:site_name" content="supergui">
<meta property="og:description" content="旗帜鲜明的站在C++的对立面">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="supergui">
<meta name="twitter:description" content="旗帜鲜明的站在C++的对立面">
  
    <link rel="alternate" href="/atom.xml" title="supergui" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">supergui</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">迁于乔木，出自幽谷</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://anticpp.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SSL-TLS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/23/SSL-TLS/" class="article-date">
  <time datetime="2016-11-23T06:12:57.000Z" itemprop="datePublished">2016-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/23/SSL-TLS/">SSL/TLS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在折腾Microservice的gRPC鉴权问题，顺带梳理了下ssl/xls的原理。<br>以前没有特别深究过里面的问题，最近大概都算理清楚了，这里Mark也下。</p>
<h1 id="1-ssl-tls"><a href="#1-ssl-tls" class="headerlink" title="1. ssl/tls"></a>1. ssl/tls</h1><p>ssl/tls是一套基于非对称加密的安全协议，实际上ssl和tls是两个版本，大多数情况下这两个名词一起被提到，可以理解为tls是ssl的升级版本。</p>
<h1 id="2-https"><a href="#2-https" class="headerlink" title="2. https"></a>2. https</h1><p>其实https是泛指http over secure，是在http协议之上增加的安全协议。当然，也有人会把它理解为http over ssl或者http over tls。<br>一般我们提到https都会默认提到ssl/tls，是因为ssl/tls在当前是最成熟的应用到https上。</p>
<h1 id="3-ssl-tls握手"><a href="#3-ssl-tls握手" class="headerlink" title="3. ssl/tls握手"></a>3. ssl/tls握手</h1><p>实际上https在安全机制上是做了两个事情，我们常常也会忽略。</p>
<ul>
<li>加密传输</li>
<li>证书校验</li>
</ul>
<p>握手的过程大概如下</p>
<ul>
<li>Client端发送ClientHello给Server端。包含协议版本、一个随机数(Random1)、支持的加密算法、压缩算法等。</li>
<li>Server端发送ServerHello给Client端。包含协议版本的确认、一个随机数(Random2)、确认的加密算法、压缩算法等。</li>
<li>Server端发送Certificate(证书)给Client端。</li>
<li>Server端发送ServerHelloDone给Client端。</li>
<li>Client端发送ClientKeyExchange给Server端。包含一个随机数PreMasterSecret，并且PreMasterSecret要用证书里面的公钥进行加密。</li>
<li><p>Server端用自己的私钥把PreMasterSecret解开。Client和Server都用Random1、Random2、PreMasterSecret算出来MasterSecret，这个MasterSecret就是双方约定的加密传输的对称秘钥，并且使用之前协商的加密算法，进行后续的数据交互。</p>
<p>  注意：</p>
<ol>
<li>Server端所持有的私钥和公钥（在Certificate里面），并没有参与Certificate校验的过程，只是用来做最后一个随机数PreMasterSecret的加密保障。</li>
<li>这个过程并没有描述Certificate在Client端是怎么验证的，也就是Client根据什么确认Server的签名信息。</li>
</ol>
</li>
</ul>
<h1 id="4-ssl-tls加密传输"><a href="#4-ssl-tls加密传输" class="headerlink" title="4. ssl/tls加密传输"></a>4. ssl/tls加密传输</h1><p>加密传输是https的最重要特性，保证了所有网络上的数据不会被明文探测。整个握手过程实际上是明文的，生成MasterSecret的前面两个随机数也是明文。实际最终保证安全性的关键在于，PreMasterSecret这个随机数的安全性。而这个随机数的安全性是建立在非对称加密的安全性上面。</p>
<h1 id="5-ssl-tls证书校验"><a href="#5-ssl-tls证书校验" class="headerlink" title="5. ssl/tls证书校验"></a>5. ssl/tls证书校验</h1><h2 id="5-1-基本原理"><a href="#5-1-基本原理" class="headerlink" title="5.1 基本原理"></a>5.1 基本原理</h2><p>证书签名的基本原理很简单，一般是利用非对称加密算法。非对秘钥一般成对出现（最常用的RSA），一个公钥，一个私钥。<br>公钥加密的信息，只有私钥能解开。同理，私钥加密的信息，只有公钥能解开。<br>例如：我用私钥加密一段内容，同时告诉对方我的公钥，对方如果可以用我的公钥解开我的内容，就可以证明这段信息是我的。这里面，被加密的内容就可以作为签名信息。</p>
<h2 id="5-2-关于CA-证书校验"><a href="#5-2-关于CA-证书校验" class="headerlink" title="5.2 关于CA/证书校验"></a>5.2 关于CA/证书校验</h2><p>ssl/tls的握手过程，往往容易忽略证书校验的过程，这个发生在握手的第3步，Server端发送证书给客户单之后，客户端是怎么验证证书的合法性呢？<br>握手的过程很简单，Server端的一组非对称秘钥，并没有参与到任何证书校验的环节，只是用来做了最后一个随机数PreMasterSecret的安全保障。</p>
<p>实际上我们Server的一对秘钥，并不是用来做证书校验，证书校验是通过另外一组非对称秘钥来保证。<br>这里就要提到<strong><em><a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="external">CA(Certificate Authority)</a></em></strong>，CA是一个权威机构，主要负责证书的签名、发放、校验等职责。<br>主要逻辑参考这个图</p>
<p><img src="/images/tls_certification.png" alt="certification_flow"></p>
<ol>
<li>CA本身有自己的一套根密钥(cakey.pem)、根证书(cacert.pem一般包含了证书信息、对应的公钥信息等)</li>
<li>Server生成自己的密钥(server_key.pem)和证书签名请求CSR(server_csr.pem)</li>
<li><p>Server拿server_csr.pem到CA进行签名，得到server_crt.pem，即最终的证书。CA签名的过程，可以简单理解为用cakey.pem对server_csr.pem增加一段加密的签名信息。这段签名信息，只有CA的公钥（公钥信息在cacert.pem可以得到）可以解开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F(cakey.pem, server_csr.pem) = server_crt.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>Client端（一般是浏览器）会内置了CA的根证书(cacert.pem)。在ssl/tls握手的第3步，Client拿到Server的Certificate（这个其实就是server_crt.pem），就可以根据CA的根证书对Certificate进行验证。</p>
</li>
</ol>
<p>所以，最终证书的安全性建立在Client端的CA根证书的安全性。</p>
<pre><code>Note: 怎么保证Client端CA证书的安全性？
</code></pre><h2 id="5-3-为什么要给钱"><a href="#5-3-为什么要给钱" class="headerlink" title="5.3 为什么要给钱"></a>5.3 为什么要给钱</h2><p>正常的网站，为了做网站的证书签名，都需要找到权威的CA机构进行证书签名，而CA对这块都是要付费的。<br>那问题是，我们为什么非得找这些CA付费，自己随便搞一个假的CA进行对自己的证书进行签名不就行了吗。<br>其实也有人这样干，大家可以参考万恶的<a href="http://www.12306.cn" target="_blank" rel="external">http://12306.cn</a>。对，就是那个全世界最大的电商网站。<br>例如用Chrome访问都会提示证书不安全，因为他们并没有找权威CA进行证书签名。<br><img src="/images/https_error.png" alt="https_error"><br>CA的权威性，是建立在行业标准之上的存在，所以对浏览器厂商也会遵循这些行业标准。也就是，这些浏览器都会内置权威的CA的根证书。为了让浏览器能显示你是认证的网站 ，必须找权威的CA机构，给钱、签名。</p>
<h1 id="6-Openssl自建CA、Server数字证书"><a href="#6-Openssl自建CA、Server数字证书" class="headerlink" title="6. Openssl自建CA、Server数字证书"></a>6. Openssl自建CA、Server数字证书</h1><p>恩，为什么要自建CA呢。<br>上面说了，ssl/tls实际上是做了两个事情，加密传输和证书验证。<br>这两个事情，其实不太相关。<br>证书验证，大部分场景是在网站浏览器端，所以网站必须给权威的CA机构付费。<br>但是，如非浏览器应用，我们只是想利用xls/tls加密传输。<br>我们就完全有理由自己搞私有的CA，自己给自己发证书了。</p>
<p>Openssl工具提供了一整套完整的命令行工具，大概流程如下<br>主要做几件事情</p>
<ol>
<li>配置自己的CA</li>
<li>生成Server的密钥，CSR</li>
<li>用CSR到CA签名，生成CRT，也就是证书</li>
</ol>
<pre><code>CSR: Certificate Signing Request，证书签名请求
CRT: Certificate，证书
</code></pre><h2 id="6-1-配置CA"><a href="#6-1-配置CA" class="headerlink" title="6.1 配置CA"></a>6.1 配置CA</h2><p>如果安装了Openssl，默认的路径在/etc/pki/。<br>配置文件路径在tls/openssl.cnf，基本的配置可以不用改。<br>可以简单关注一下policy_match相关的配置，这里配置了对不同证书信息是否进行校验。</p>
<ul>
<li><p>进入CA目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd CA/</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建两个文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch index.txt serial</span><br><span class="line">echo 01 &gt; serial</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建根密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out private/cakey.pem 2048</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建根证书<br>需要用到密钥 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -key private/cakey.pem -out cacert.pem</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-2-配置Server"><a href="#6-2-配置Server" class="headerlink" title="6.2 配置Server"></a>6.2 配置Server</h2><ul>
<li><p>生成Server密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server_key.pem 2048</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成Server CSR<br>需要用到密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server_key.pem -out server_csr.pem</span><br><span class="line">...</span><br><span class="line">Country Name (2 letter code) [AU]:CN</span><br><span class="line">State or Province Name (full name) [Some-State]:GD</span><br><span class="line">Locality Name (eg, city) []:SZ</span><br><span class="line">Organization Name (eg, company) [Internet Widgits Pty Ltd]:COMPANY</span><br><span class="line">Organizational Unit Name (eg, section) []:IT_SECTION</span><br><span class="line">Common Name (e.g. server FQDN or YOUR name) []:your.domain.com</span><br><span class="line">Email Address []:</span><br><span class="line"></span><br><span class="line">Please enter the following &apos;extra&apos; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:</span><br><span class="line">An optional company name []:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-3-证书签名"><a href="#6-3-证书签名" class="headerlink" title="6.3 证书签名"></a>6.3 证书签名</h2><p>把上一步的server_csr.pem发给CA机器，在CA机器上执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -in server_csr.pem -out server_crt.pem</span><br></pre></td></tr></table></figure></p>
<h2 id="6-4-完成"><a href="#6-4-完成" class="headerlink" title="6.4 完成"></a>6.4 完成</h2><p>Server端持有: 密钥server_key.pem、证书server_crt.pem<br>Client端持有: CA的根证书cacert.pem</p>
<p>双方即可进行ssl/tls握手通信</p>
<h1 id="7-ssl-tls双向校验"><a href="#7-ssl-tls双向校验" class="headerlink" title="7. ssl/tls双向校验"></a>7. ssl/tls双向校验</h1><p>因为在做gRPC鉴权的时候，我们需要的Server端对Client进行身份鉴权，于是发现ssl/tls是支持双向鉴权。<br>简单来说就是，除了Client端对Server端进行证书鉴权，Server端也会要求对Client进行证书鉴权。</p>
<p>握手过程如下，加粗的步骤是新增的。</p>
<ul>
<li>Client端发送ClientHello给Server端。包含协议版本、一个随机数(Random1)、支持的加密算法、压缩算法等。</li>
<li>Server端发送ServerHello给Client端。包含协议版本的确认、一个随机数(Random2)、确认的加密算法、压缩算法等。</li>
<li>Server端发送Certificate(证书)给Client端。</li>
<li><strong><strong>Server端发送Certificate Request给Client端，要求Client端提供证书。</strong></strong></li>
<li>Server端发送ServerHelloDone给Client端。</li>
<li><strong><strong>Client端发送Certificate给Server端。</strong></strong></li>
<li>Client端发送ClientKeyExchange给Server端。包含随机数PreMasterSecret，并且PreMasterSecret要用证书的公钥进行加密。</li>
<li>Client和Server端用Random1、Random2、PreMasterSecret算出来MasterSecret，这个MasterSecret就是双方约定的加密传输的对称秘钥，并且使用之前协商的加密算法，进行后续的数据交互。</li>
</ul>
<p>服务器拿到Client端的Certificate，进行类似Client端对Server端的Certificate校验过程，这样就实现了双向校验。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/11/23/SSL-TLS/" data-id="cklu9c49600027rp3aebg6mj2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="udp_about-udp包的问题" class="article article-type-udp_about" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/11/14/udp包的问题/" class="article-date">
  <time datetime="2016-11-14T11:51:27.000Z" itemprop="datePublished">2016-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/11/14/udp包的问题/">udp包的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近研究了一下udp相关的东西，做下笔记。<br>这里有相关的<a href="https://www.github.com/anticpp/experiments" target="_blank" rel="external">测试代码</a>。</p>
<h1 id="udp包一般多少适合"><a href="#udp包一般多少适合" class="headerlink" title="udp包一般多少适合"></a>udp包一般多少适合</h1><p>协议层的限制，理论上我们可以发送接收65535(0xFFFF)大小的udp包。为了避免IP层分片，udp包在ethernet上一般不超过1472(1500-20-8)，1500为ethernet的链路MTU。<br>实际上很多应用（例如DNS）的udp包都不超过512，为什么呢？</p>
<p>这是Stack Overflow上面的一句话<br>    The maximum safe UDP payload is 508 bytes. This is a packet size of 576, minus the maximum 60-byte IP header and the 8-byte UDP header. Any UDP payload this size or smaller is guaranteed to be deliverable over IP (though not guaranteed to be delivered). Anything larger is allowed to be outright dropped by any router for any reason.<br>按照字面理解的意思是，大于576的udp包在路由链路保证不了一定传输，难道是路由器的实现潜规则？</p>
<ul>
<li>更新At 2016-11-14<br>似乎RFC的IPV4标准里面有定义。</li>
</ul>
<p>RFC 791 excerpt:<br>…<br>All hosts must be prepared to accept datagrams of up to 576 octets ( whether they arrive whole or in fragments ). It is recommended that hosts only send datagrams larger than 576 octets if they have assurance that the destination is prepared to accept the larger datagrams.<br>The number 576 is selected to allow a reasonable sized data block to be transmitted in addition to the required header information. For example, this size allows a data block of 512 octets plus 64 header octets to fit in a datagram. The maximal internet header is 60 octets, and a typical internet header is 20 octets, allowing a margin for headers of higher level protocols.<br>…</p>
<p>既然这样，另外一个问题来了，为什么TCP的MSS一般不受这个限制。<br>是因为TCP有做链路MTU探测，以及稳定的重传机制吗？</p>
<h1 id="udp-socket缓冲区"><a href="#udp-socket缓冲区" class="headerlink" title="udp socket缓冲区"></a>udp socket缓冲区</h1><ol>
<li><p>发送缓冲区<br>经常有一个误解是udp没有发送缓冲区，实际udp也有发送缓冲区。只不过udp并不是流协议，发送缓冲区只会缓存一个包，然后立刻就被拷贝到内核协议栈。<br>如果发送一个超过缓冲区大小的udp包，大多数的实现是直接丢弃。</p>
</li>
<li><p>接收缓冲区<br>接收缓冲区跟发送缓冲区有点不一样，所有的udp包会按照先后顺序缓存，应用层每次读会返回最早的包。实际上接收缓冲区就是FIFO队列。<br>如果接收缓冲区大小不够，大多数的实现是直接丢弃整个包。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/11/14/udp包的问题/" data-id="cklu9c49r000k7rp3c4z4f5pq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ffmpeg" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/31/ffmpeg/" class="article-date">
  <time datetime="2016-03-31T13:05:06.000Z" itemprop="datePublished">2016-03-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/31/ffmpeg/">ffmpeg</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ffmpeg使用"><a href="#ffmpeg使用" class="headerlink" title="ffmpeg使用"></a>ffmpeg使用</h1><h1 id="发布rtmp流"><a href="#发布rtmp流" class="headerlink" title="发布rtmp流"></a>发布rtmp流</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -loglevel verbose -re -i test.flv -vcodec libx264  -vprofile baseline -acodec libmp3lame -ar 44100 -ac 1 -f flv &apos;rtmp://10.10.159.119:1935/app1/2&apos;</span><br></pre></td></tr></table></figure>
<h1 id="ffmpeg安装"><a href="#ffmpeg安装" class="headerlink" title="ffmpeg安装"></a>ffmpeg安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-libmp3lame --enable-libx264 --enable-libfdk-aac --enable-gpl --extra-cflags=-I/usr/local/include --extra-ldflags=-L/usr/local/lib --extra-libs=-ldl --enable-nonfree</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/03/31/ffmpeg/" data-id="cklu9c49500017rp3oevzh7j4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/视频/">视频</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-python-gevent和go-coroutine对比" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/15/python-gevent和go-coroutine对比/" class="article-date">
  <time datetime="2016-03-15T02:26:39.000Z" itemprop="datePublished">2016-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/15/python-gevent和go-coroutine对比/">python-gevent和go-coroutine对比</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>针对python-threading、python-gevent和go-coroutine进行压测对比</p>
<h2 id="压测环境"><a href="#压测环境" class="headerlink" title="压测环境"></a>压测环境</h2><ul>
<li>压测机器是我的一台阿里云ECS机器</li>
<li>CPU x86_64 单核</li>
<li>内存 1G</li>
<li>操作系统Linux iZ94mudtv23Z 2.6.32-431.23.3.el6.x86_64 Centos 6.5</li>
<li>python 2.7</li>
<li>go 1.5.1</li>
</ul>
<h2 id="压测模型"><a href="#压测模型" class="headerlink" title="压测模型"></a>压测模型</h2><ul>
<li>测试不同并发上下文情况下，进程占用内存、CPU的情况</li>
<li>并发数由1000逐步递增到50000</li>
</ul>
<h2 id="压测数据"><a href="#压测数据" class="headerlink" title="压测数据"></a>压测数据</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><img src="/images/bench_vmem.png" alt="bench_vmem"></p>
<h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><p><img src="/images/bench_mem.png" alt="bench_mem"></p>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p><img src="/images/bench_cpu.png" alt="bench_cpu"></p>
<h2 id="压测结论"><a href="#压测结论" class="headerlink" title="压测结论"></a>压测结论</h2><ul>
<li>总体性能比较go-coroutine &gt; python-gevent &gt; python-threading</li>
<li>python-threading基本到15000并发数就上不去，可能是系统资源已经到了瓶颈</li>
<li>python-gevent在并发数较小时表现不错，随着并发数上涨，内存和CPU的增长也较快</li>
<li>python-gevent一开始就吃虚拟内存比较多</li>
<li>go-coroutine性能表现出色，随着并发数上涨，内存和CPU占用都维持在比较平稳的水平</li>
<li>总的来说不管是python-gevent还是go-coroutine，在用户态进行的context调度，比内核的threading消耗小很多</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p><a href="https://github.com/anticpp/coroutine_benchmark" target="_blank" rel="external">github代码</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/03/15/python-gevent和go-coroutine对比/" data-id="cklu9c49n000e7rp3gkwc701v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hexo安装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/29/hexo安装/" class="article-date">
  <time datetime="2016-02-29T11:58:22.000Z" itemprop="datePublished">2016-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/29/hexo安装/">hexo安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>折腾了下hexo的环境，用来做自己的markdown博客还是相当不错，还支持github部署。这里讲一下怎么安装。</p>
<p><a href="https://hexo.io/" target="_blank" rel="external">hexo官网</a><br><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">hexo github地址</a></p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>hexo是基于nodejs的插件实现，需要先安装nodejs<br>安装办法参考<a href="http://nodejs.cn/" target="_blank" rel="external">nodejs官网</a>。</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><pre><code>npm install -g hexo
</code></pre><h2 id="初始化blog"><a href="#初始化blog" class="headerlink" title="初始化blog"></a>初始化blog</h2><p>例如我的博客目录在~/blog/，则cd到~目录执行初始化，如下</p>
<pre><code>cd ~
hexo init blog
cd blog
npm install
</code></pre><h2 id="启动hexo-server"><a href="#启动hexo-server" class="headerlink" title="启动hexo-server"></a>启动hexo-server</h2><pre><code>cd ~/blog/
hexo server
</code></pre><p>hexo会启动一个监听4000端口的http服务器，输出信息</p>
<pre><code>INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.
</code></pre><h2 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h2><pre><code>hexo generate
</code></pre><h2 id="本地查看"><a href="#本地查看" class="headerlink" title="本地查看"></a>本地查看</h2><p>在浏览器输入地址<code>http://localhost:4000/</code>，即可看到你的博客页面。</p>
<h2 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h2><pre><code>hexo new &quot;page1&quot;
</code></pre><h2 id="github部署"><a href="#github部署" class="headerlink" title="github部署"></a>github部署</h2><p><a href="https://pages.github.com/" target="_blank" rel="external">github page</a>是github提供的公开网页托管服务。可以把网页push到github仓库，然后可以通过公开域名访问。</p>
<p>hexo支持进行github page部署。具体步骤如下</p>
<ol>
<li><p>在你的github上面创建仓库，名字为’username’.github.io。<br> ‘username’为你的github账号。</p>
</li>
<li><p>配置_config.xml<br>例如我的github账号为anticpp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:anticpp/anticpp.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>部署<br> hexo deploy</p>
</li>
</ol>
<p><code>note:</code><br><code>如果出现错误信息&#39;ERROR Deployer not found: git&#39;，尝试安装以下组件</code></p>
<pre><code>npm install hexo-deployer-git --save
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/02/29/hexo安装/" data-id="cklu9c49j00097rp3yan0jbkz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/markdown/">markdown</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ssh信任关系" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/02/29/ssh信任关系/" class="article-date">
  <time datetime="2016-02-29T11:26:15.000Z" itemprop="datePublished">2016-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/29/ssh信任关系/">ssh信任关系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>自动ssh登录，我写了一个autossh的工具。<br>有兴趣的朋友可以试试<a href="https://github.com/anticpp/autossh" target="_blank" rel="external">autossh</a></p>
</blockquote>
<blockquote>
<p>回到正题，A要ssh登陆到B，不想输入密码。可以在B建立一个对A的ssh信任关系即可。<br>ssh的信任关系是通过rsa实现，具体的操作步骤如下:</p>
</blockquote>
<h2 id="A机器生成rsa-key"><a href="#A机器生成rsa-key" class="headerlink" title="A机器生成rsa key"></a>A机器生成rsa key</h2><ul>
<li>进入~/.ssh/</li>
<li>运行ssh-keygen，所有的提示都默认回车即可</li>
<li>拷贝公钥，cat id_rsa.pub</li>
</ul>
<h2 id="B机器添加公钥"><a href="#B机器添加公钥" class="headerlink" title="B机器添加公钥"></a>B机器添加公钥</h2><ul>
<li>进入~/.ssh/</li>
<li>把A生成的公钥，添加到authorized_keys</li>
</ul>
<h2 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h2><ul>
<li>从A登陆B机器，无需密码</li>
</ul>
<p><code>注意:</code><br><code>非root账号的ssh信任关系一直都还不行，网上很多资料都说是文件权限问题，试了下都不行。</code><br><code>所以暂时未解，后面找到原因再跟进到文档。</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://anticpp.github.io/2016/02/29/ssh信任关系/" data-id="cklu9c49s000n7rp3q7g43h3s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go-C-virtual-interface/">Go C++ virtual interface</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IP/">IP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/p2p-dht/">p2p dht</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/视频/">视频</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go-C-virtual-interface/" style="font-size: 10px;">Go C++ virtual interface</a> <a href="/tags/IP/" style="font-size: 10px;">IP</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/p2p-dht/" style="font-size: 10px;">p2p dht</a> <a href="/tags/技术/" style="font-size: 20px;">技术</a> <a href="/tags/视频/" style="font-size: 10px;">视频</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/04/message-queue/">message-queue</a>
          </li>
        
          <li>
            <a href="/2018/05/11/gopher-2018/">gopher-2018</a>
          </li>
        
          <li>
            <a href="/2018/05/05/cpp-virtual-vs-go-interface/">Go interface internal</a>
          </li>
        
          <li>
            <a href="/2018/05/03/private-addr/">IPV4私有地址</a>
          </li>
        
          <li>
            <a href="/2018/04/17/dht/">DHT</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 supergui@live.cn<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>